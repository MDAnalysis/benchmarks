{
    "GRO.GROReadBench.time_create_GRO_universe": {
        "code": "class GROReadBench:\n    def time_create_GRO_universe(self):\n        \"\"\"Time to create MDA Universe of GRO\"\"\"\n        u = mda.Universe(GRO)",
        "min_run_count": 2,
        "name": "GRO.GROReadBench.time_create_GRO_universe",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "85e9386a1154d866631322425b43e682903a28a89efb74527110189dcbd24a4a",
        "warmup_time": -1
    },
    "GRO.GROReadBench.time_parse_GRO_file": {
        "code": "class GROReadBench:\n    def time_parse_GRO_file(self):\n        \"\"\"Time to create topology from GRO file\"\"\"\n        p = GROParser(GRO)\n        top = p.parse()",
        "min_run_count": 2,
        "name": "GRO.GROReadBench.time_parse_GRO_file",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "7d0bec284a3cc88727c887e20b4d7a7a6fb3dc8b9a3fed98a8bee728f5920227",
        "warmup_time": -1
    },
    "GRO.GROReadBench.time_read_GRO_coordinates": {
        "code": "class GROReadBench:\n    def time_read_GRO_coordinates(self):\n        \"\"\"Benchmark reading of standard testsuite GRO file.\"\"\"\n        GROReader(GRO)",
        "min_run_count": 2,
        "name": "GRO.GROReadBench.time_read_GRO_coordinates",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "987e7a4b2431ce8645e1a4d7c1135f76c9b35e5eb29b0f6818860f96531be147",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupAttrsBench.time_angle": {
        "code": "class AtomGroupAttrsBench:\n    def time_angle(self, num_atoms):\n        \"\"\"Benchmark simple angle\n        calculation. Requires ag\n        with three atoms.\n        \"\"\"\n        self.ag[:3].angle\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]",
        "min_run_count": 2,
        "name": "ag_methods.AtomGroupAttrsBench.time_angle",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "a83a2ce99c0673f57ac3eac16b49a9db026ae64b6fcaa4389bf47eed59124dbb",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupAttrsBench.time_atomcount": {
        "code": "class AtomGroupAttrsBench:\n    def time_atomcount(self, num_atoms):\n        \"\"\"Benchmark counting of atoms in\n        atomgroup.\n        \"\"\"\n        self.ag.n_atoms\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]",
        "min_run_count": 2,
        "name": "ag_methods.AtomGroupAttrsBench.time_atomcount",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "d31f8341e31a7bc198133f258c72536b54ec904f97ac4f28a767f9970856818a",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupAttrsBench.time_atoms": {
        "code": "class AtomGroupAttrsBench:\n    def time_atoms(self, num_atoms):\n        \"\"\"Benchmark returning of identical\n        atomgroup.\n        \"\"\"\n        self.ag.atoms\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]",
        "min_run_count": 2,
        "name": "ag_methods.AtomGroupAttrsBench.time_atoms",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "6cd2f945901dc324d1dabcb388bc3fe0c3b5977d49056e5d7a7859c40e2c9af8",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupAttrsBench.time_bond": {
        "code": "class AtomGroupAttrsBench:\n    def time_bond(self, num_atoms):\n        \"\"\"Benchmark Bond object creation.\n        Requires ag of size 2.\n        \"\"\"\n        self.ag[:2].bond\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]",
        "min_run_count": 2,
        "name": "ag_methods.AtomGroupAttrsBench.time_bond",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "3507b8355b5b01697e086a646c559412d09fde51fc7139f4524f7cb58aa7ae67",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupAttrsBench.time_dihedral": {
        "code": "class AtomGroupAttrsBench:\n    def time_dihedral(self, num_atoms):\n        \"\"\"Benchmark Dihedral object\n        creation time. Requires ag of\n        size 4.\n        \"\"\"\n        self.ag[:4].dihedral\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]",
        "min_run_count": 2,
        "name": "ag_methods.AtomGroupAttrsBench.time_dihedral",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "5775f1a2f7666febcc47f94b77702bd75a2a7ccd7c9044265c965dbad779a351",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupAttrsBench.time_forces": {
        "code": "class AtomGroupAttrsBench:\n    def time_forces(self, num_atoms):\n        \"\"\"Benchmark atomgroup force\n        calculation.\n        \"\"\"\n        try:\n            self.ag.forces\n        except NoDataError:\n            pass\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]",
        "min_run_count": 2,
        "name": "ag_methods.AtomGroupAttrsBench.time_forces",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "0186fc73e76b8e3f8cb39e7e11f7c6e9837d800b2379b14591432ee9e710d69e",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupAttrsBench.time_improper": {
        "code": "class AtomGroupAttrsBench:\n    def time_improper(self, num_atoms):\n        \"\"\"Benchmark improper dihedral\n        calculation. Requires ag of size\n        4.\n        \"\"\"\n        self.ag[:4].improper\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]",
        "min_run_count": 2,
        "name": "ag_methods.AtomGroupAttrsBench.time_improper",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "d7ba217b21841225ff1df0b473d66794db6b2c92c56bbb3cb04c042fb43e967c",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupAttrsBench.time_indices": {
        "code": "class AtomGroupAttrsBench:\n    def time_indices(self, num_atoms):\n        \"\"\"Benchmark atom index calculation.\"\"\"\n        self.ag.ix\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]",
        "min_run_count": 2,
        "name": "ag_methods.AtomGroupAttrsBench.time_indices",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "a2f8e96416fe7631705ff183a4764d2d4777030b1d3a504d779ff621697c4063",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupAttrsBench.time_positions": {
        "code": "class AtomGroupAttrsBench:\n    def time_positions(self, num_atoms):\n        \"\"\"Benchmark returning the positions\n        of the atoms in the group.\n        \"\"\"\n        self.ag.positions\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]",
        "min_run_count": 2,
        "name": "ag_methods.AtomGroupAttrsBench.time_positions",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "7f538e5ccf7c68b715cb9ba1f0a85764faa5e09216ba83be3b88804f26504dcd",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupAttrsBench.time_residuecount": {
        "code": "class AtomGroupAttrsBench:\n    def time_residuecount(self, num_atoms):\n        \"\"\"Benchmark counting of residues in\n        atomgroup.\n        \"\"\"\n        self.ag.n_residues\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]",
        "min_run_count": 2,
        "name": "ag_methods.AtomGroupAttrsBench.time_residuecount",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "6ba8023af1d40da84022b2eba1e494b20eb80d1257fa5beabc2206f8d380b237",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupAttrsBench.time_residues": {
        "code": "class AtomGroupAttrsBench:\n    def time_residues(self, num_atoms):\n        \"\"\"Benchmark creation of the ResidueGroup\n        from the AtomGroup.\n        \"\"\"\n        self.ag.residues\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]",
        "min_run_count": 2,
        "name": "ag_methods.AtomGroupAttrsBench.time_residues",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "72655f2bf91db254ada1b26646da826894a223384a4691f99b06b291107b938e",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupAttrsBench.time_segmentcount": {
        "code": "class AtomGroupAttrsBench:\n    def time_segmentcount(self, num_atoms):\n        \"\"\"Benchmark counting of segments in\n        atomgroup.\n        \"\"\"\n        self.ag.n_segments\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]",
        "min_run_count": 2,
        "name": "ag_methods.AtomGroupAttrsBench.time_segmentcount",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "ea9ccc59b78a3786c8ed142a014c476162b2d37437c8f93a4b05644dd851aede",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupAttrsBench.time_segments": {
        "code": "class AtomGroupAttrsBench:\n    def time_segments(self, num_atoms):\n        \"\"\"Benchmark determination of sorted\n        SegmentGroup from AtomGroup.\n        \"\"\"\n        self.ag.segments\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]",
        "min_run_count": 2,
        "name": "ag_methods.AtomGroupAttrsBench.time_segments",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "ec21432839b2caac695337844d8b3feff546e74083cc61d846692523160bcf70",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupAttrsBench.time_ts": {
        "code": "class AtomGroupAttrsBench:\n    def time_ts(self, num_atoms):\n        \"\"\"Benchmark returning of a timestep\n        instance from atomgroup.\n        \"\"\"\n        self.ag.ts\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]",
        "min_run_count": 2,
        "name": "ag_methods.AtomGroupAttrsBench.time_ts",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "0aadba3b29a020c1edbc55253049c8f9dc252759321e51f110ca895d99ce52a6",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupAttrsBench.time_unique": {
        "code": "class AtomGroupAttrsBench:\n    def time_unique(self, num_atoms):\n        \"\"\"Benchmark determination of unique\n        elements in atomgroup.\n        \"\"\"\n        self.ag.unique\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]",
        "min_run_count": 2,
        "name": "ag_methods.AtomGroupAttrsBench.time_unique",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "1c2345530d78545ab7011e17420325ec0f2b12a472ade667a7253fd672a06f70",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupAttrsBench.time_velocity": {
        "code": "class AtomGroupAttrsBench:\n    def time_velocity(self, num_atoms):\n        \"\"\"Benchmark atomgroup velocity\n        values return.\n        \"\"\"\n        try:\n            self.ag.velocities\n        except NoDataError:\n            pass\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]",
        "min_run_count": 2,
        "name": "ag_methods.AtomGroupAttrsBench.time_velocity",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "3841e8cfb0518bdc257c0479f3844b8bdf80ee1e2bf7b2245ba4ba95533e2ce8",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_bbox_no_pbc": {
        "code": "class AtomGroupMethodsBench:\n    def time_bbox_no_pbc(self, num_atoms):\n        \"\"\"Benchmark bounding box calculation\n        with pbc inactive.\n        \"\"\"\n        self.ag.bbox(pbc=False)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {\"H\": 1.0, \"C\": 1.0, \"N\": 1.0, \"O\": 1.0, \"DUMMY\": 1.0}\n        self.rot_matrix = np.ones((3, 3))\n        self.trans = np.ones((4, 4))",
        "min_run_count": 2,
        "name": "ag_methods.AtomGroupMethodsBench.time_bbox_no_pbc",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "26494a1dcc4a1a4689c90c1861b1a5f2f78466f6bdcffe71ee64ea59bae4f719",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_bbox_pbc": {
        "code": "class AtomGroupMethodsBench:\n    def time_bbox_pbc(self, num_atoms):\n        \"\"\"Benchmark bounding box calculation\n        with pbc active.\n        \"\"\"\n        self.ag.bbox(pbc=True)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {\"H\": 1.0, \"C\": 1.0, \"N\": 1.0, \"O\": 1.0, \"DUMMY\": 1.0}\n        self.rot_matrix = np.ones((3, 3))\n        self.trans = np.ones((4, 4))",
        "min_run_count": 2,
        "name": "ag_methods.AtomGroupMethodsBench.time_bbox_pbc",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "2b465ed3a0f2cc59c5191f4177ac0c9a5e3a284ae8cdf7a3812d74092b449f4e",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_bsphere_no_pbc": {
        "code": "class AtomGroupMethodsBench:\n    def time_bsphere_no_pbc(self, num_atoms):\n        \"\"\"Benchmark bounding sphere calculation\n        with pbc inactive.\n        \"\"\"\n        self.ag.bsphere(pbc=False)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {\"H\": 1.0, \"C\": 1.0, \"N\": 1.0, \"O\": 1.0, \"DUMMY\": 1.0}\n        self.rot_matrix = np.ones((3, 3))\n        self.trans = np.ones((4, 4))",
        "min_run_count": 2,
        "name": "ag_methods.AtomGroupMethodsBench.time_bsphere_no_pbc",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "9448a21e51dca393ca0e9157d25e9d415967eb27ad298ad23aa6657ed936df68",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_bsphere_pbc": {
        "code": "class AtomGroupMethodsBench:\n    def time_bsphere_pbc(self, num_atoms):\n        \"\"\"Benchmark bounding sphere calculation\n        with pbc active.\n        \"\"\"\n        self.ag.bsphere(pbc=True)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {\"H\": 1.0, \"C\": 1.0, \"N\": 1.0, \"O\": 1.0, \"DUMMY\": 1.0}\n        self.rot_matrix = np.ones((3, 3))\n        self.trans = np.ones((4, 4))",
        "min_run_count": 2,
        "name": "ag_methods.AtomGroupMethodsBench.time_bsphere_pbc",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "634f01f83de863d143c64fd928b30e6b60369ccaa2b83337eb0a53857739921c",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_center_no_pbc": {
        "code": "class AtomGroupMethodsBench:\n    def time_center_no_pbc(self, num_atoms):\n        \"\"\"Benchmark center calculation with\n        pbc inactive.\n        \"\"\"\n        self.ag.center(weights=self.weights, pbc=False)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {\"H\": 1.0, \"C\": 1.0, \"N\": 1.0, \"O\": 1.0, \"DUMMY\": 1.0}\n        self.rot_matrix = np.ones((3, 3))\n        self.trans = np.ones((4, 4))",
        "min_run_count": 2,
        "name": "ag_methods.AtomGroupMethodsBench.time_center_no_pbc",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "1cd3d6874ed60490469063af34c4cce2b3324ffaa68aa57cdbf54f2b245f9c28",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_center_pbc": {
        "code": "class AtomGroupMethodsBench:\n    def time_center_pbc(self, num_atoms):\n        \"\"\"Benchmark center calculation with\n        pbc active.\n        \"\"\"\n        self.ag.center(weights=self.weights, pbc=True)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {\"H\": 1.0, \"C\": 1.0, \"N\": 1.0, \"O\": 1.0, \"DUMMY\": 1.0}\n        self.rot_matrix = np.ones((3, 3))\n        self.trans = np.ones((4, 4))",
        "min_run_count": 2,
        "name": "ag_methods.AtomGroupMethodsBench.time_center_pbc",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "6946eea2123c3deafd840eca21a524d9211e083e6b1f295ed268c62791fe1a86",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_centroid_no_pbc": {
        "code": "class AtomGroupMethodsBench:\n    def time_centroid_no_pbc(self, num_atoms):\n        \"\"\"Benchmark centroid calculation with\n        pbc inactive.\n        \"\"\"\n        self.ag.centroid(pbc=False)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {\"H\": 1.0, \"C\": 1.0, \"N\": 1.0, \"O\": 1.0, \"DUMMY\": 1.0}\n        self.rot_matrix = np.ones((3, 3))\n        self.trans = np.ones((4, 4))",
        "min_run_count": 2,
        "name": "ag_methods.AtomGroupMethodsBench.time_centroid_no_pbc",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "74da865e5589b2f7834a3c2c30b02c0275e9b63ecc890b5c7f1420b1ba23274f",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_centroid_pbc": {
        "code": "class AtomGroupMethodsBench:\n    def time_centroid_pbc(self, num_atoms):\n        \"\"\"Benchmark centroid calculation with\n        pbc active.\n        \"\"\"\n        self.ag.centroid(pbc=True)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {\"H\": 1.0, \"C\": 1.0, \"N\": 1.0, \"O\": 1.0, \"DUMMY\": 1.0}\n        self.rot_matrix = np.ones((3, 3))\n        self.trans = np.ones((4, 4))",
        "min_run_count": 2,
        "name": "ag_methods.AtomGroupMethodsBench.time_centroid_pbc",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "5ed19c52530a065d039a0660ccb44b0b68350984945730ad4c2870e39927cb2f",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_concatenate": {
        "code": "class AtomGroupMethodsBench:\n    def time_concatenate(self, num_atoms):\n        \"\"\"Benchmark atomgroup concatenation.\"\"\"\n        self.ag.concatenate(self.ag)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {\"H\": 1.0, \"C\": 1.0, \"N\": 1.0, \"O\": 1.0, \"DUMMY\": 1.0}\n        self.rot_matrix = np.ones((3, 3))\n        self.trans = np.ones((4, 4))",
        "min_run_count": 2,
        "name": "ag_methods.AtomGroupMethodsBench.time_concatenate",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "d2f6db2e6c5ffdd45b381156e48f4fa996c5356a12f21ba904c782fa3726817c",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_difference": {
        "code": "class AtomGroupMethodsBench:\n    def time_difference(self, num_atoms):\n        \"\"\"Benchmark atomgroup difference\n        operation.\n        \"\"\"\n        self.ag.difference(self.ag)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {\"H\": 1.0, \"C\": 1.0, \"N\": 1.0, \"O\": 1.0, \"DUMMY\": 1.0}\n        self.rot_matrix = np.ones((3, 3))\n        self.trans = np.ones((4, 4))",
        "min_run_count": 2,
        "name": "ag_methods.AtomGroupMethodsBench.time_difference",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "0ef483915b8a62471062f6114285e9921eee6851818f81d63925b7060ebc2af2",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_groupby": {
        "code": "class AtomGroupMethodsBench:\n    def time_groupby(self, num_atoms):\n        \"\"\"Benchmark atomgroup groupby\n        operation.\n        \"\"\"\n        self.ag.groupby(\"resnames\")\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {\"H\": 1.0, \"C\": 1.0, \"N\": 1.0, \"O\": 1.0, \"DUMMY\": 1.0}\n        self.rot_matrix = np.ones((3, 3))\n        self.trans = np.ones((4, 4))",
        "min_run_count": 2,
        "name": "ag_methods.AtomGroupMethodsBench.time_groupby",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "0e2a32bfa0a0e770ad1040d023f895ee3083c975e5ef4a0d590a4a3d3f9b0b52",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_guess_bonds": {
        "code": "class AtomGroupMethodsBench:\n    def time_guess_bonds(self, num_atoms):\n        \"\"\"Benchmark atomgroup bond guessing\n        with artificially-seeded vdw values.\n        \"\"\"\n        self.ag.guess_bonds(self.vdwradii)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {\"H\": 1.0, \"C\": 1.0, \"N\": 1.0, \"O\": 1.0, \"DUMMY\": 1.0}\n        self.rot_matrix = np.ones((3, 3))\n        self.trans = np.ones((4, 4))",
        "min_run_count": 2,
        "name": "ag_methods.AtomGroupMethodsBench.time_guess_bonds",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "be60aa33d04f135d2bac5ca56bf80f6d035ee8e0b1c7c6b981baf46c5d760526",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_intersection": {
        "code": "class AtomGroupMethodsBench:\n    def time_intersection(self, num_atoms):\n        \"\"\"Benchmark ag intersection.\"\"\"\n        self.ag.intersection(self.ag)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {\"H\": 1.0, \"C\": 1.0, \"N\": 1.0, \"O\": 1.0, \"DUMMY\": 1.0}\n        self.rot_matrix = np.ones((3, 3))\n        self.trans = np.ones((4, 4))",
        "min_run_count": 2,
        "name": "ag_methods.AtomGroupMethodsBench.time_intersection",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "6e1444eb0683c7fe2269e49c77c13c69220b918097643645e7806c3c71fb90cb",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_is_strict_subset": {
        "code": "class AtomGroupMethodsBench:\n    def time_is_strict_subset(self, num_atoms):\n        \"\"\"Benchmark ag strict subset operation.\"\"\"\n        self.ag.is_strict_subset(self.ag)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {\"H\": 1.0, \"C\": 1.0, \"N\": 1.0, \"O\": 1.0, \"DUMMY\": 1.0}\n        self.rot_matrix = np.ones((3, 3))\n        self.trans = np.ones((4, 4))",
        "min_run_count": 2,
        "name": "ag_methods.AtomGroupMethodsBench.time_is_strict_subset",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "b7298efde65530559391417e143199d84c3db3749e22ae7af1f59cd13939843c",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_is_strict_superset": {
        "code": "class AtomGroupMethodsBench:\n    def time_is_strict_superset(self, num_atoms):\n        \"\"\"Benchmark ag strict superset operation.\"\"\"\n        self.ag.is_strict_superset(self.ag)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {\"H\": 1.0, \"C\": 1.0, \"N\": 1.0, \"O\": 1.0, \"DUMMY\": 1.0}\n        self.rot_matrix = np.ones((3, 3))\n        self.trans = np.ones((4, 4))",
        "min_run_count": 2,
        "name": "ag_methods.AtomGroupMethodsBench.time_is_strict_superset",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "34c40ad1e9c29261d8d93672bac6a090ccef15545db75a3e1b34c4903dabf728",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_isdisjoint": {
        "code": "class AtomGroupMethodsBench:\n    def time_isdisjoint(self, num_atoms):\n        \"\"\"Benchmark disjoint operation between\n        atomgroups.\n        \"\"\"\n        self.ag.isdisjoint(self.ag)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {\"H\": 1.0, \"C\": 1.0, \"N\": 1.0, \"O\": 1.0, \"DUMMY\": 1.0}\n        self.rot_matrix = np.ones((3, 3))\n        self.trans = np.ones((4, 4))",
        "min_run_count": 2,
        "name": "ag_methods.AtomGroupMethodsBench.time_isdisjoint",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "41cb461dbf3737e49032da6899de0d878252a1cafa63ebd4f2d15c9e1f63390e",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_issubset": {
        "code": "class AtomGroupMethodsBench:\n    def time_issubset(self, num_atoms):\n        \"\"\"Benchmark subset operation between\n        atomgroups.\n        \"\"\"\n        self.ag.issubset(self.ag)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {\"H\": 1.0, \"C\": 1.0, \"N\": 1.0, \"O\": 1.0, \"DUMMY\": 1.0}\n        self.rot_matrix = np.ones((3, 3))\n        self.trans = np.ones((4, 4))",
        "min_run_count": 2,
        "name": "ag_methods.AtomGroupMethodsBench.time_issubset",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "9494e19a1321bf54cd0e157398feaf737595d23ae3f2dc7d2c54e0b34efeda62",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_issuperset": {
        "code": "class AtomGroupMethodsBench:\n    def time_issuperset(self, num_atoms):\n        \"\"\"Benchmark superset operation between\n        atomgroups.\n        \"\"\"\n        self.ag.issuperset(self.ag)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {\"H\": 1.0, \"C\": 1.0, \"N\": 1.0, \"O\": 1.0, \"DUMMY\": 1.0}\n        self.rot_matrix = np.ones((3, 3))\n        self.trans = np.ones((4, 4))",
        "min_run_count": 2,
        "name": "ag_methods.AtomGroupMethodsBench.time_issuperset",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "444b05d226308a873fa5adf59724befc229163a10e0c8833f8c371ef73f574f0",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_pack_into_box": {
        "code": "class AtomGroupMethodsBench:\n    def time_pack_into_box(self, num_atoms):\n        \"\"\"Benchmark shifting atoms of ag\n        into primary unit cell, using\n        default parameters.\n        \"\"\"\n        self.ag.pack_into_box()\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {\"H\": 1.0, \"C\": 1.0, \"N\": 1.0, \"O\": 1.0, \"DUMMY\": 1.0}\n        self.rot_matrix = np.ones((3, 3))\n        self.trans = np.ones((4, 4))",
        "min_run_count": 2,
        "name": "ag_methods.AtomGroupMethodsBench.time_pack_into_box",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "37f3040ba5aee1a65ce538b3991d31f9252a61152d0f4bdb5393d117e683d6fa",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_rotate": {
        "code": "class AtomGroupMethodsBench:\n    def time_rotate(self, num_atoms):\n        \"\"\"Benchmark simple rotation operation\n        on atomgroup.\n        \"\"\"\n        self.ag.rotate(self.rot_matrix)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {\"H\": 1.0, \"C\": 1.0, \"N\": 1.0, \"O\": 1.0, \"DUMMY\": 1.0}\n        self.rot_matrix = np.ones((3, 3))\n        self.trans = np.ones((4, 4))",
        "min_run_count": 2,
        "name": "ag_methods.AtomGroupMethodsBench.time_rotate",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "2d6ba175c24b04d22146d60d6a7f3a1c3243a9c70427f1d60ea60ceda697ce15",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_rotateby": {
        "code": "class AtomGroupMethodsBench:\n    def time_rotateby(self, num_atoms):\n        \"\"\"Benchmark rotation by an angle\n        of the ag coordinates.\n        \"\"\"\n        self.ag.rotateby(angle=45, axis=[1, 0, 0])\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {\"H\": 1.0, \"C\": 1.0, \"N\": 1.0, \"O\": 1.0, \"DUMMY\": 1.0}\n        self.rot_matrix = np.ones((3, 3))\n        self.trans = np.ones((4, 4))",
        "min_run_count": 2,
        "name": "ag_methods.AtomGroupMethodsBench.time_rotateby",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "54bafca4671398ccd04cf6d61ed666bc577dd52c3d6a28f7d8c82619df043295",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_split": {
        "code": "class AtomGroupMethodsBench:\n    def time_split(self, num_atoms):\n        \"\"\"Benchmark ag splitting into\n        multiple ags based on a simple\n        criterion.\n        \"\"\"\n        self.ag.split(\"residue\")\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {\"H\": 1.0, \"C\": 1.0, \"N\": 1.0, \"O\": 1.0, \"DUMMY\": 1.0}\n        self.rot_matrix = np.ones((3, 3))\n        self.trans = np.ones((4, 4))",
        "min_run_count": 2,
        "name": "ag_methods.AtomGroupMethodsBench.time_split",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "7dea2c12e359c92d2d511e0b7022da4a7839f24fb109d85c26a60396523103df",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_subtract": {
        "code": "class AtomGroupMethodsBench:\n    def time_subtract(self, num_atoms):\n        \"\"\"Benchmark ag subtraction.\"\"\"\n        self.ag.subtract(self.ag)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {\"H\": 1.0, \"C\": 1.0, \"N\": 1.0, \"O\": 1.0, \"DUMMY\": 1.0}\n        self.rot_matrix = np.ones((3, 3))\n        self.trans = np.ones((4, 4))",
        "min_run_count": 2,
        "name": "ag_methods.AtomGroupMethodsBench.time_subtract",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "4ce589a356b69d280ba0f2b87f0b76d21998a7ae6fba1f52e9ad15e25d315693",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_symmetric_difference": {
        "code": "class AtomGroupMethodsBench:\n    def time_symmetric_difference(self, num_atoms):\n        \"\"\"Benchmark ag symmetric difference\n        operation.\n        \"\"\"\n        self.ag.symmetric_difference(self.ag)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {\"H\": 1.0, \"C\": 1.0, \"N\": 1.0, \"O\": 1.0, \"DUMMY\": 1.0}\n        self.rot_matrix = np.ones((3, 3))\n        self.trans = np.ones((4, 4))",
        "min_run_count": 2,
        "name": "ag_methods.AtomGroupMethodsBench.time_symmetric_difference",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "831eea9a64f8f533ad57b4df8e9505511c11d9cdda224a113db44dcac813bcea",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_transform": {
        "code": "class AtomGroupMethodsBench:\n    def time_transform(self, num_atoms):\n        \"\"\"Benchmark application of transformation\n        matrix to atomgroup.\n        \"\"\"\n        self.ag.transform(self.trans)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {\"H\": 1.0, \"C\": 1.0, \"N\": 1.0, \"O\": 1.0, \"DUMMY\": 1.0}\n        self.rot_matrix = np.ones((3, 3))\n        self.trans = np.ones((4, 4))",
        "min_run_count": 2,
        "name": "ag_methods.AtomGroupMethodsBench.time_transform",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "f8935c5772a2e9a24227bfc5692b5bb0b2a1ee93aac1153631b64e98227bc1c1",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_translate": {
        "code": "class AtomGroupMethodsBench:\n    def time_translate(self, num_atoms):\n        \"\"\"Benchmark the application of a\n        translation vector to the ag\n        coordinates.\n        \"\"\"\n        self.ag.translate([0, 0.5, 1])\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {\"H\": 1.0, \"C\": 1.0, \"N\": 1.0, \"O\": 1.0, \"DUMMY\": 1.0}\n        self.rot_matrix = np.ones((3, 3))\n        self.trans = np.ones((4, 4))",
        "min_run_count": 2,
        "name": "ag_methods.AtomGroupMethodsBench.time_translate",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "8ae044d20ddfe16423f7e8577e43b3049bb0c8bfe8b09b2b4e9be57ee8d9e05e",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_union": {
        "code": "class AtomGroupMethodsBench:\n    def time_union(self, num_atoms):\n        \"\"\"Benchmark union operation\n        on atomgroups.\n        \"\"\"\n        self.ag.union(self.ag)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {\"H\": 1.0, \"C\": 1.0, \"N\": 1.0, \"O\": 1.0, \"DUMMY\": 1.0}\n        self.rot_matrix = np.ones((3, 3))\n        self.trans = np.ones((4, 4))",
        "min_run_count": 2,
        "name": "ag_methods.AtomGroupMethodsBench.time_union",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "98349a976dc351b4c346632220763f0366ca46dcd6f2789f7369c04d3f6e2d88",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_wrap": {
        "code": "class AtomGroupMethodsBench:\n    def time_wrap(self, num_atoms):\n        \"\"\"Benchmark wrap() operation on\n        atomgroup with default params.\n        \"\"\"\n        self.ag.wrap()\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {\"H\": 1.0, \"C\": 1.0, \"N\": 1.0, \"O\": 1.0, \"DUMMY\": 1.0}\n        self.rot_matrix = np.ones((3, 3))\n        self.trans = np.ones((4, 4))",
        "min_run_count": 2,
        "name": "ag_methods.AtomGroupMethodsBench.time_wrap",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "49b51f0de454d966e6a7a72845e1926c32041253563c0c80c1b4d53a050e53ea",
        "warmup_time": -1
    },
    "ag_methods.CompoundSplitting.time_center_compounds": {
        "code": "class CompoundSplitting:\n    def time_center_compounds(self, *args):\n        self.u.atoms.center(None, compound=\"residues\")\n\n    def setup(self, n_atoms, n_compounds, homogeneous, contiguous):\n        rg = np.random.Generator(np.random.MT19937(3000))\n    \n        # some parameter screening for nonsensical combinations.\n        if n_compounds > n_atoms:\n            raise NotImplementedError\n    \n        if n_compounds == 1 and not (homogeneous and contiguous):\n            raise NotImplementedError\n    \n        if n_compounds == n_atoms:\n            if not (homogeneous and contiguous):\n                raise NotImplementedError\n            compound_indices = np.arange(n_compounds)\n        elif homogeneous:\n            ats_per_compound, remainder = divmod(n_atoms, n_compounds)\n            if remainder:\n                raise NotImplementedError\n            compound_indices = np.tile(\n                np.arange(n_compounds), (ats_per_compound, 1)\n            ).T.ravel()\n        else:\n            compound_indices = np.sort(\n                np.floor(rg.random(n_atoms) * n_compounds).astype(np.int64)\n            )\n    \n        unique_indices = np.unique(compound_indices)\n        if len(unique_indices) != n_compounds:\n            raise RuntimeError\n    \n        if not contiguous:\n            rg.shuffle(compound_indices)\n    \n        self.u = MDAnalysis.Universe.empty(\n            n_atoms,\n            n_residues=n_compounds,\n            n_segments=1,\n            atom_resindex=compound_indices,\n            trajectory=True,\n        )\n        self.u.atoms.positions = rg.random((n_atoms, 3), dtype=np.float32) * 100\n        self.u.dimensions = [50, 50, 50, 90, 90, 90]",
        "min_run_count": 2,
        "name": "ag_methods.CompoundSplitting.time_center_compounds",
        "number": 0,
        "param_names": [
            "param1",
            "param2",
            "param3",
            "param4"
        ],
        "params": [
            [
                "100",
                "10000",
                "1000000"
            ],
            [
                "1",
                "10",
                "100"
            ],
            [
                "True",
                "False"
            ],
            [
                "True",
                "False"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "3b08dd073522deb3c6518f16bcda19ae15eb2d0e65d51caf65e995bdc08097c9",
        "warmup_time": -1
    },
    "ag_methods.FragmentCaching.time_find_cached_fragments": {
        "code": "class FragmentCaching:\n    def time_find_cached_fragments(self, universe_type):\n        frags = self.u.atoms.fragments\n\n    def setup(self, universe_type):\n        super(FragmentCaching, self).setup(universe_type)\n        frags = self.u.atoms.fragments  # Priming the cache",
        "min_run_count": 2,
        "name": "ag_methods.FragmentCaching.time_find_cached_fragments",
        "number": 0,
        "param_names": [
            "universe_type"
        ],
        "params": [
            [
                "'large_fragment_small_solvents'",
                "'large_fragment'",
                "'polymer_chains'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "e10a712eaf0f8c9a2489bc4f2dbc9677be29528aa3314aa5bcb814b05e4c5cd8",
        "warmup_time": -1
    },
    "ag_methods.FragmentCaching.time_find_fragments": {
        "code": "class FragmentFinding:\n    def time_find_fragments(self, universe_type):\n        frags = self.u.atoms.fragments\n\nclass FragmentCaching:\n    def setup(self, universe_type):\n        super(FragmentCaching, self).setup(universe_type)\n        frags = self.u.atoms.fragments  # Priming the cache",
        "min_run_count": 2,
        "name": "ag_methods.FragmentCaching.time_find_fragments",
        "number": 0,
        "param_names": [
            "universe_type"
        ],
        "params": [
            [
                "'large_fragment_small_solvents'",
                "'large_fragment'",
                "'polymer_chains'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "9ee4ba9d30022cba05eab57475bff54164b9f4ffc8a37286663ae8befdd78225",
        "warmup_time": -1
    },
    "ag_methods.FragmentFinding.time_find_fragments": {
        "code": "class FragmentFinding:\n    def time_find_fragments(self, universe_type):\n        frags = self.u.atoms.fragments\n\n    def setup(self, universe_type):\n        if universe_type == \"large_fragment_small_solvents\":\n            univ = (TPR, XTC)\n        elif universe_type == \"large_fragment\":\n            univ = (PSF, DCD)\n        else:\n            univ = (TRZ_psf, TRZ)\n        self.u = MDAnalysis.Universe(*univ)",
        "min_run_count": 2,
        "name": "ag_methods.FragmentFinding.time_find_fragments",
        "number": 0,
        "param_names": [
            "universe_type"
        ],
        "params": [
            [
                "'large_fragment_small_solvents'",
                "'large_fragment'",
                "'polymer_chains'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "1c576e2dccd2cd5d9501e5e6236462caab545dee1c3d97575fe48e6515211b30",
        "warmup_time": -1
    },
    "analysis.distances.DistancesBench.time_between": {
        "code": "class DistancesBench:\n    def time_between(self, num_atoms):\n        \"\"\"Benchmark determination of subgroup\n        of atomgroup that is within a specific\n        distance of two other atomgroups.\n        \"\"\"\n        distances.between(group=self.ag3, A=self.ag1, B=self.ag2, distance=15.0)\n\n    def setup(self, num_atoms):\n        np.random.seed(17809)\n        self.coords_1 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(9008716)\n        self.coords_2 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(15809)\n        self.coords_3 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(871600)\n        self.coords_4 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n    \n        self.allocated_array_2D = np.empty((num_atoms, num_atoms), dtype=np.float64)\n        self.array_shape_1D = int(num_atoms * (num_atoms - 1) / 2.0)\n        self.allocated_array_1D = np.empty(self.array_shape_1D, dtype=np.float64)\n        self.u = mda.Universe(GRO)\n        self.ag1 = self.u.atoms[:num_atoms]\n        self.ag2 = self.u.atoms[num_atoms : 2 * num_atoms]\n        self.ag3 = self.u.atoms[-num_atoms:]",
        "min_run_count": 2,
        "name": "analysis.distances.DistancesBench.time_between",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "f7cb926c7830aca51019b8cd5d6d62921c9a6c19a3977574650a8e1010f7ca63",
        "warmup_time": -1
    },
    "analysis.distances.DistancesBench.time_calc_angles": {
        "code": "class DistancesBench:\n    def time_calc_angles(self, num_atoms):\n        \"\"\"Benchmark calculation of angles between\n        atoms in three atomgroups.\n        \"\"\"\n        mda.lib.distances.calc_angles(self.coords_1, self.coords_2, self.coords_3)\n\n    def setup(self, num_atoms):\n        np.random.seed(17809)\n        self.coords_1 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(9008716)\n        self.coords_2 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(15809)\n        self.coords_3 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(871600)\n        self.coords_4 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n    \n        self.allocated_array_2D = np.empty((num_atoms, num_atoms), dtype=np.float64)\n        self.array_shape_1D = int(num_atoms * (num_atoms - 1) / 2.0)\n        self.allocated_array_1D = np.empty(self.array_shape_1D, dtype=np.float64)\n        self.u = mda.Universe(GRO)\n        self.ag1 = self.u.atoms[:num_atoms]\n        self.ag2 = self.u.atoms[num_atoms : 2 * num_atoms]\n        self.ag3 = self.u.atoms[-num_atoms:]",
        "min_run_count": 2,
        "name": "analysis.distances.DistancesBench.time_calc_angles",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "b4d4fd16fe3468cfe0f5156c69ddf22f3096cb050f4adf059fc08ab472556b52",
        "warmup_time": -1
    },
    "analysis.distances.DistancesBench.time_calc_bonds": {
        "code": "class DistancesBench:\n    def time_calc_bonds(self, num_atoms):\n        \"\"\"Benchmark calculation of bonds between\n        atoms in two atomgroups.\n        \"\"\"\n        mda.lib.distances.calc_bonds(self.coords_1, self.coords_2)\n\n    def setup(self, num_atoms):\n        np.random.seed(17809)\n        self.coords_1 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(9008716)\n        self.coords_2 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(15809)\n        self.coords_3 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(871600)\n        self.coords_4 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n    \n        self.allocated_array_2D = np.empty((num_atoms, num_atoms), dtype=np.float64)\n        self.array_shape_1D = int(num_atoms * (num_atoms - 1) / 2.0)\n        self.allocated_array_1D = np.empty(self.array_shape_1D, dtype=np.float64)\n        self.u = mda.Universe(GRO)\n        self.ag1 = self.u.atoms[:num_atoms]\n        self.ag2 = self.u.atoms[num_atoms : 2 * num_atoms]\n        self.ag3 = self.u.atoms[-num_atoms:]",
        "min_run_count": 2,
        "name": "analysis.distances.DistancesBench.time_calc_bonds",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "5d80b15d40307e6373295e90fa46d778646c8b7510e49f23b311fab258af0f7a",
        "warmup_time": -1
    },
    "analysis.distances.DistancesBench.time_calc_dihedrals": {
        "code": "class DistancesBench:\n    def time_calc_dihedrals(self, num_atoms):\n        \"\"\"Benchmark calculation of dihedrals between\n        atoms in four atomgroups.\n        \"\"\"\n        mda.lib.distances.calc_dihedrals(\n            self.coords_1, self.coords_2, self.coords_3, self.coords_4\n        )\n\n    def setup(self, num_atoms):\n        np.random.seed(17809)\n        self.coords_1 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(9008716)\n        self.coords_2 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(15809)\n        self.coords_3 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(871600)\n        self.coords_4 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n    \n        self.allocated_array_2D = np.empty((num_atoms, num_atoms), dtype=np.float64)\n        self.array_shape_1D = int(num_atoms * (num_atoms - 1) / 2.0)\n        self.allocated_array_1D = np.empty(self.array_shape_1D, dtype=np.float64)\n        self.u = mda.Universe(GRO)\n        self.ag1 = self.u.atoms[:num_atoms]\n        self.ag2 = self.u.atoms[num_atoms : 2 * num_atoms]\n        self.ag3 = self.u.atoms[-num_atoms:]",
        "min_run_count": 2,
        "name": "analysis.distances.DistancesBench.time_calc_dihedrals",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "a1cfa8903d6cc500cad1aa8f155bc62d3222f45f9b39882e1f24570142829185",
        "warmup_time": -1
    },
    "analysis.distances.DistancesBench.time_contact_matrix": {
        "code": "class DistancesBench:\n    def time_contact_matrix(self, num_atoms):\n        \"\"\"Benchmark calculation of contacts within\n        a single numpy array using the default arguments\n        to contact_matrix.\n        \"\"\"\n        distances.contact_matrix(\n            coord=self.coords_1, cutoff=15.0, returntype=\"numpy\", box=None\n        )\n\n    def setup(self, num_atoms):\n        np.random.seed(17809)\n        self.coords_1 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(9008716)\n        self.coords_2 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(15809)\n        self.coords_3 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(871600)\n        self.coords_4 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n    \n        self.allocated_array_2D = np.empty((num_atoms, num_atoms), dtype=np.float64)\n        self.array_shape_1D = int(num_atoms * (num_atoms - 1) / 2.0)\n        self.allocated_array_1D = np.empty(self.array_shape_1D, dtype=np.float64)\n        self.u = mda.Universe(GRO)\n        self.ag1 = self.u.atoms[:num_atoms]\n        self.ag2 = self.u.atoms[num_atoms : 2 * num_atoms]\n        self.ag3 = self.u.atoms[-num_atoms:]",
        "min_run_count": 2,
        "name": "analysis.distances.DistancesBench.time_contact_matrix",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "e0ef9482216629a1fe21ff8a7c2fa129a130acb06187553b27cf702fcedc6c56",
        "warmup_time": -1
    },
    "analysis.distances.DistancesBench.time_contact_matrix_sparse": {
        "code": "class DistancesBench:\n    def time_contact_matrix_sparse(self, num_atoms):\n        \"\"\"Benchmark calculation of contacts within\n        a single numpy array using the slower reduced\n        memory implementation of contact_matrix intended\n        for larger systems.\n        \"\"\"\n        distances.contact_matrix(\n            coord=self.coords_1, cutoff=15.0, returntype=\"sparse\", box=None\n        )\n\n    def setup(self, num_atoms):\n        np.random.seed(17809)\n        self.coords_1 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(9008716)\n        self.coords_2 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(15809)\n        self.coords_3 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(871600)\n        self.coords_4 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n    \n        self.allocated_array_2D = np.empty((num_atoms, num_atoms), dtype=np.float64)\n        self.array_shape_1D = int(num_atoms * (num_atoms - 1) / 2.0)\n        self.allocated_array_1D = np.empty(self.array_shape_1D, dtype=np.float64)\n        self.u = mda.Universe(GRO)\n        self.ag1 = self.u.atoms[:num_atoms]\n        self.ag2 = self.u.atoms[num_atoms : 2 * num_atoms]\n        self.ag3 = self.u.atoms[-num_atoms:]",
        "min_run_count": 2,
        "name": "analysis.distances.DistancesBench.time_contact_matrix_sparse",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "477391d2a502d773052eff441523ff042258296e9dac3c28724a100da1a8cb82",
        "warmup_time": -1
    },
    "analysis.distances.DistancesBench.time_dist": {
        "code": "class DistancesBench:\n    def time_dist(self, num_atoms):\n        \"\"\"Benchmark calculation of distances between\n        atoms in two atomgroups with no offsets\n        to resids.\n        \"\"\"\n        distances.dist(A=self.ag1, B=self.ag2, offset=0)\n\n    def setup(self, num_atoms):\n        np.random.seed(17809)\n        self.coords_1 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(9008716)\n        self.coords_2 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(15809)\n        self.coords_3 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(871600)\n        self.coords_4 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n    \n        self.allocated_array_2D = np.empty((num_atoms, num_atoms), dtype=np.float64)\n        self.array_shape_1D = int(num_atoms * (num_atoms - 1) / 2.0)\n        self.allocated_array_1D = np.empty(self.array_shape_1D, dtype=np.float64)\n        self.u = mda.Universe(GRO)\n        self.ag1 = self.u.atoms[:num_atoms]\n        self.ag2 = self.u.atoms[num_atoms : 2 * num_atoms]\n        self.ag3 = self.u.atoms[-num_atoms:]",
        "min_run_count": 2,
        "name": "analysis.distances.DistancesBench.time_dist",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "a769084c687a124dcbefdeced52c8fb1e64dab5bf3c4299723c6b6bf0d2f4348",
        "warmup_time": -1
    },
    "analysis.distances.DistancesBench.time_dist_offsets": {
        "code": "class DistancesBench:\n    def time_dist_offsets(self, num_atoms):\n        \"\"\"Benchmark calculation of distances between\n        atoms in two atomgroups with offsets\n        to resids.\n        \"\"\"\n        distances.dist(A=self.ag1, B=self.ag2, offset=20)\n\n    def setup(self, num_atoms):\n        np.random.seed(17809)\n        self.coords_1 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(9008716)\n        self.coords_2 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(15809)\n        self.coords_3 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(871600)\n        self.coords_4 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n    \n        self.allocated_array_2D = np.empty((num_atoms, num_atoms), dtype=np.float64)\n        self.array_shape_1D = int(num_atoms * (num_atoms - 1) / 2.0)\n        self.allocated_array_1D = np.empty(self.array_shape_1D, dtype=np.float64)\n        self.u = mda.Universe(GRO)\n        self.ag1 = self.u.atoms[:num_atoms]\n        self.ag2 = self.u.atoms[num_atoms : 2 * num_atoms]\n        self.ag3 = self.u.atoms[-num_atoms:]",
        "min_run_count": 2,
        "name": "analysis.distances.DistancesBench.time_dist_offsets",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "ad369d5ac97aca36922d72a3b19119ee9cf242730f850758c16bc579c91f85a4",
        "warmup_time": -1
    },
    "analysis.distances.DistancesBench.time_distance_array": {
        "code": "class DistancesBench:\n    def time_distance_array(self, num_atoms):\n        \"\"\"Benchmark calculation of all distances\n        between two numpy arrays of coordinates,\n        using default arguments to distance_array.\n        \"\"\"\n        distances.distance_array(\n            reference=self.coords_1,\n            configuration=self.coords_2,\n            box=None,\n            result=None,\n            backend=\"serial\",\n        )\n\n    def setup(self, num_atoms):\n        np.random.seed(17809)\n        self.coords_1 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(9008716)\n        self.coords_2 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(15809)\n        self.coords_3 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(871600)\n        self.coords_4 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n    \n        self.allocated_array_2D = np.empty((num_atoms, num_atoms), dtype=np.float64)\n        self.array_shape_1D = int(num_atoms * (num_atoms - 1) / 2.0)\n        self.allocated_array_1D = np.empty(self.array_shape_1D, dtype=np.float64)\n        self.u = mda.Universe(GRO)\n        self.ag1 = self.u.atoms[:num_atoms]\n        self.ag2 = self.u.atoms[num_atoms : 2 * num_atoms]\n        self.ag3 = self.u.atoms[-num_atoms:]",
        "min_run_count": 2,
        "name": "analysis.distances.DistancesBench.time_distance_array",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "3a9c6792fa70838f213ce12f4a0b7bc2414fec681e02c0940d0c9d6695f490fc",
        "warmup_time": -1
    },
    "analysis.distances.DistancesBench.time_distance_array_pre_allocated": {
        "code": "class DistancesBench:\n    def time_distance_array_pre_allocated(self, num_atoms):\n        \"\"\"Benchmark calculation of all distances\n        between two numpy arrays of coordinates,\n        using distance_array with a preallocated\n        result array.\n        \"\"\"\n        distances.distance_array(\n            reference=self.coords_1,\n            configuration=self.coords_2,\n            box=None,\n            result=self.allocated_array_2D,\n            backend=\"serial\",\n        )\n\n    def setup(self, num_atoms):\n        np.random.seed(17809)\n        self.coords_1 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(9008716)\n        self.coords_2 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(15809)\n        self.coords_3 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(871600)\n        self.coords_4 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n    \n        self.allocated_array_2D = np.empty((num_atoms, num_atoms), dtype=np.float64)\n        self.array_shape_1D = int(num_atoms * (num_atoms - 1) / 2.0)\n        self.allocated_array_1D = np.empty(self.array_shape_1D, dtype=np.float64)\n        self.u = mda.Universe(GRO)\n        self.ag1 = self.u.atoms[:num_atoms]\n        self.ag2 = self.u.atoms[num_atoms : 2 * num_atoms]\n        self.ag3 = self.u.atoms[-num_atoms:]",
        "min_run_count": 2,
        "name": "analysis.distances.DistancesBench.time_distance_array_pre_allocated",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "4469720eff804354f8b4eec99f41598136c57a90d20d558fb5eeb104cc67521e",
        "warmup_time": -1
    },
    "analysis.distances.DistancesBench.time_self_distance_array": {
        "code": "class DistancesBench:\n    def time_self_distance_array(self, num_atoms):\n        \"\"\"Benchmark calculation of all distances\n        within a single numpy array of coordinates\n        using default parameters to self_distance_array.\n        \"\"\"\n        distances.self_distance_array(\n            reference=self.coords_1, box=None, result=None, backend=\"serial\"\n        )\n\n    def setup(self, num_atoms):\n        np.random.seed(17809)\n        self.coords_1 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(9008716)\n        self.coords_2 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(15809)\n        self.coords_3 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(871600)\n        self.coords_4 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n    \n        self.allocated_array_2D = np.empty((num_atoms, num_atoms), dtype=np.float64)\n        self.array_shape_1D = int(num_atoms * (num_atoms - 1) / 2.0)\n        self.allocated_array_1D = np.empty(self.array_shape_1D, dtype=np.float64)\n        self.u = mda.Universe(GRO)\n        self.ag1 = self.u.atoms[:num_atoms]\n        self.ag2 = self.u.atoms[num_atoms : 2 * num_atoms]\n        self.ag3 = self.u.atoms[-num_atoms:]",
        "min_run_count": 2,
        "name": "analysis.distances.DistancesBench.time_self_distance_array",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "49d6cbae6ad313a0cc696e782fe2b9121060c01505a64d164cff85f42219f1df",
        "warmup_time": -1
    },
    "analysis.distances.DistancesBench.time_self_distance_array_pre_allocated": {
        "code": "class DistancesBench:\n    def time_self_distance_array_pre_allocated(self, num_atoms):\n        \"\"\"Benchmark calculation of all distances\n        within a single numpy array of coordinates\n        using self_distance_array with preallocated\n        result array.\n        \"\"\"\n        distances.self_distance_array(\n            reference=self.coords_1,\n            box=None,\n            result=self.allocated_array_1D,\n            backend=\"serial\",\n        )\n\n    def setup(self, num_atoms):\n        np.random.seed(17809)\n        self.coords_1 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(9008716)\n        self.coords_2 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(15809)\n        self.coords_3 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(871600)\n        self.coords_4 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n    \n        self.allocated_array_2D = np.empty((num_atoms, num_atoms), dtype=np.float64)\n        self.array_shape_1D = int(num_atoms * (num_atoms - 1) / 2.0)\n        self.allocated_array_1D = np.empty(self.array_shape_1D, dtype=np.float64)\n        self.u = mda.Universe(GRO)\n        self.ag1 = self.u.atoms[:num_atoms]\n        self.ag2 = self.u.atoms[num_atoms : 2 * num_atoms]\n        self.ag3 = self.u.atoms[-num_atoms:]",
        "min_run_count": 2,
        "name": "analysis.distances.DistancesBench.time_self_distance_array_pre_allocated",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "907c16b59582a436c14922784f57285f11415e1c05c473f2b252c198aab249dd",
        "warmup_time": -1
    },
    "analysis.leaflet.LeafletBench.time_leafletfinder": {
        "code": "class LeafletBench:\n    def time_leafletfinder(self, cutoff, sparse, pbc):\n        \"\"\"Benchmark LeafletFinder for test lipid\n        membrane system.\n        \"\"\"\n        leaflet.LeafletFinder(\n            universe=self.u,\n            select=self.headgroup_sel,\n            cutoff=cutoff,\n            pbc=pbc,\n            sparse=sparse,\n        )\n\n    def setup(self, cutoff, sparse, pbc):\n        self.u = MDAnalysis.Universe(Martini_membrane_gro)\n        self.headgroup_sel = \"name PO4\"",
        "min_run_count": 2,
        "name": "analysis.leaflet.LeafletBench.time_leafletfinder",
        "number": 0,
        "param_names": [
            "cutoff",
            "sparse",
            "pbc"
        ],
        "params": [
            [
                "7.0",
                "15.0",
                "23.0"
            ],
            [
                "None",
                "True",
                "False"
            ],
            [
                "True",
                "False"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "a537a0210accf6bb3202fa3a4e727a24d194d0ed585c5da976fee38ff7afdd94",
        "warmup_time": -1
    },
    "analysis.leaflet.LeafletOptimizeBench.time_optimize_cutoff": {
        "code": "class LeafletOptimizeBench:\n    def time_optimize_cutoff(self, sparse, pbc):\n        \"\"\"Benchmark optimize_cutoff for test lipid\n        membrane system using default network distance\n        range.\n        \"\"\"\n        leaflet.optimize_cutoff(\n            universe=self.u, select=self.headgroup_sel, pbc=pbc, sparse=sparse\n        )\n\n    def setup(self, sparse, pbc):\n        self.u = MDAnalysis.Universe(Martini_membrane_gro)\n        self.headgroup_sel = \"name PO4\"",
        "min_run_count": 2,
        "name": "analysis.leaflet.LeafletOptimizeBench.time_optimize_cutoff",
        "number": 0,
        "param_names": [
            "sparse",
            "pbc"
        ],
        "params": [
            [
                "None",
                "True",
                "False"
            ],
            [
                "True",
                "False"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "912b45c752ea32b45838cacef576deffbd89b00438e5d2f5573dd8297a679151",
        "warmup_time": -1
    },
    "analysis.psa.PSA_get_coord_axesBench.time_get_coord_axes": {
        "code": "class PSA_get_coord_axesBench:\n    def time_get_coord_axes(self, time_steps, n_atoms):\n        \"\"\"Benchmark get_coord_axes in psa module\"\"\"\n        psa.get_coord_axes(path=self.path)\n\n    def setup(self, time_steps, n_atoms):\n        np.random.seed(170089)\n        # only using condensed path input\n        # data structure for now\n        self.path = np.random.rand(time_steps, n_atoms * 3)",
        "min_run_count": 2,
        "name": "analysis.psa.PSA_get_coord_axesBench.time_get_coord_axes",
        "number": 0,
        "param_names": [
            "time_steps",
            "n_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000"
            ],
            [
                "5",
                "25",
                "50"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "e89a125391aa2b63a660ea57d50bb75cad36be949e3b6504a336a9d1033e572a",
        "warmup_time": -1
    },
    "analysis.psa.PSA_get_msd_matrixBench.time_get_msd_matrix": {
        "code": "class PSA_get_msd_matrixBench:\n    def time_get_msd_matrix(self, time_steps, n_atoms):\n        \"\"\"Benchmark for get_msd_matrix in psa module\"\"\"\n        # only default argument for axis is benchmarked\n        psa.get_msd_matrix(P=self.P, Q=self.Q, axis=None)\n\n    def setup(self, time_steps, n_atoms):\n        np.random.seed(170089)\n        self.P = np.random.rand(time_steps, n_atoms, 3)\n        np.random.seed(971132)\n        self.Q = np.random.rand(time_steps, n_atoms, 3)",
        "min_run_count": 2,
        "name": "analysis.psa.PSA_get_msd_matrixBench.time_get_msd_matrix",
        "number": 0,
        "param_names": [
            "time_steps",
            "n_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000"
            ],
            [
                "5",
                "25",
                "50"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "736c4937cfa197d9a716d8482f7cf5b78abd453e06deb4208af57605acd78277",
        "warmup_time": -1
    },
    "analysis.psa.PSA_get_path_metric_funcBench.time_get_path_metric_func": {
        "code": "class PSA_get_path_metric_funcBench:\n    def time_get_path_metric_func(self, path_metric):\n        \"\"\"Benchmark for get_path_metric_func in psa\n        module\n        \"\"\"\n        psa.get_path_metric_func(name=path_metric)",
        "min_run_count": 2,
        "name": "analysis.psa.PSA_get_path_metric_funcBench.time_get_path_metric_func",
        "number": 0,
        "param_names": [
            "path_metric"
        ],
        "params": [
            [
                "'hausdorff'",
                "'weighted_average_hausdorff'",
                "'average_hausdorff'",
                "'hausdorff_neighbors'",
                "'discrete_frechet'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "fc71d48ec5e111b5f38e7d741ab5f63fc3c8615325be6916878225ada0d3e828",
        "warmup_time": -1
    },
    "analysis.psa.PSA_metricBench.time_discrete_frechet": {
        "code": "class PSA_metricBench:\n    def time_discrete_frechet(self, time_steps, n_atoms):\n        \"\"\"Benchmark for discrete_frechet() in psa module.\"\"\"\n        psa.discrete_frechet(P=self.P, Q=self.Q)\n\n    def setup(self, time_steps, n_atoms):\n        np.random.seed(170089)\n        self.P = np.random.rand(time_steps, n_atoms, 3)\n        np.random.seed(971132)\n        self.Q = np.random.rand(time_steps, n_atoms, 3)",
        "min_run_count": 2,
        "name": "analysis.psa.PSA_metricBench.time_discrete_frechet",
        "number": 0,
        "param_names": [
            "time_steps",
            "n_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "200"
            ],
            [
                "5",
                "25",
                "50"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "dffa94b368c34e897e375273426afc9b380f5b35216d1b40cc2767067e0952ae",
        "warmup_time": -1
    },
    "analysis.psa.PSA_metricBench.time_hausdorff": {
        "code": "class PSA_metricBench:\n    def time_hausdorff(self, time_steps, n_atoms):\n        \"\"\"Benchmark for hausdorff() in psa module.\"\"\"\n        psa.hausdorff(P=self.P, Q=self.Q)\n\n    def setup(self, time_steps, n_atoms):\n        np.random.seed(170089)\n        self.P = np.random.rand(time_steps, n_atoms, 3)\n        np.random.seed(971132)\n        self.Q = np.random.rand(time_steps, n_atoms, 3)",
        "min_run_count": 2,
        "name": "analysis.psa.PSA_metricBench.time_hausdorff",
        "number": 0,
        "param_names": [
            "time_steps",
            "n_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "200"
            ],
            [
                "5",
                "25",
                "50"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "3c30f407071d83e6a1b904ba675b2dc76a913f0cfe02250cba6cff55a886528e",
        "warmup_time": -1
    },
    "analysis.psa.PSA_metricBench.time_hausdorff_avg": {
        "code": "class PSA_metricBench:\n    def time_hausdorff_avg(self, time_steps, n_atoms):\n        \"\"\"Benchmark for hausdorff_avg() in psa module.\"\"\"\n        psa.hausdorff_avg(P=self.P, Q=self.Q)\n\n    def setup(self, time_steps, n_atoms):\n        np.random.seed(170089)\n        self.P = np.random.rand(time_steps, n_atoms, 3)\n        np.random.seed(971132)\n        self.Q = np.random.rand(time_steps, n_atoms, 3)",
        "min_run_count": 2,
        "name": "analysis.psa.PSA_metricBench.time_hausdorff_avg",
        "number": 0,
        "param_names": [
            "time_steps",
            "n_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "200"
            ],
            [
                "5",
                "25",
                "50"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "4a0f7a58daf0ef1c3d9195542654a8c05eabd040133859ae0ce799463db28caa",
        "warmup_time": -1
    },
    "analysis.psa.PSA_metricBench.time_hausdorff_neighbors": {
        "code": "class PSA_metricBench:\n    def time_hausdorff_neighbors(self, time_steps, n_atoms):\n        \"\"\"Benchmark for hausdorff_neighbors() in psa module.\"\"\"\n        psa.hausdorff_neighbors(P=self.P, Q=self.Q)\n\n    def setup(self, time_steps, n_atoms):\n        np.random.seed(170089)\n        self.P = np.random.rand(time_steps, n_atoms, 3)\n        np.random.seed(971132)\n        self.Q = np.random.rand(time_steps, n_atoms, 3)",
        "min_run_count": 2,
        "name": "analysis.psa.PSA_metricBench.time_hausdorff_neighbors",
        "number": 0,
        "param_names": [
            "time_steps",
            "n_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "200"
            ],
            [
                "5",
                "25",
                "50"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "57280db97f4c188f62e457ad7aea8be5df4aeaacb1ff79bd65bf01e86b975b8a",
        "warmup_time": -1
    },
    "analysis.psa.PSA_metricBench.time_hausdorff_wavg": {
        "code": "class PSA_metricBench:\n    def time_hausdorff_wavg(self, time_steps, n_atoms):\n        \"\"\"Benchmark for hausdorff_wavg() in psa module.\"\"\"\n        psa.hausdorff_wavg(P=self.P, Q=self.Q)\n\n    def setup(self, time_steps, n_atoms):\n        np.random.seed(170089)\n        self.P = np.random.rand(time_steps, n_atoms, 3)\n        np.random.seed(971132)\n        self.Q = np.random.rand(time_steps, n_atoms, 3)",
        "min_run_count": 2,
        "name": "analysis.psa.PSA_metricBench.time_hausdorff_wavg",
        "number": 0,
        "param_names": [
            "time_steps",
            "n_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "200"
            ],
            [
                "5",
                "25",
                "50"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "5f1c44b40bb977fd6afc3a2cf88a108fd7cae37ebd87c2376f9b1f5a570a5410",
        "warmup_time": -1
    },
    "analysis.psa.PSA_sqnormBench.time_sqnorm": {
        "code": "class PSA_sqnormBench:\n    def time_sqnorm(self, num_cols, num_rows, axis):\n        \"\"\"Benchmark sqnorm in psa module\"\"\"\n        psa.sqnorm(v=self.v, axis=axis)\n\n    def setup(self, num_cols, num_rows, axis):\n        np.random.seed(170089)\n        self.v = np.random.rand(num_rows, num_cols)",
        "min_run_count": 2,
        "name": "analysis.psa.PSA_sqnormBench.time_sqnorm",
        "number": 0,
        "param_names": [
            "num_cols",
            "num_rows",
            "axis"
        ],
        "params": [
            [
                "2",
                "3",
                "4"
            ],
            [
                "100",
                "1000",
                "10000"
            ],
            [
                "None",
                "0",
                "1",
                "-1"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "07fd8b0f5826c0c2bcce7d6422ac6549039cbf8be209196a3aa3a928c7ff684a",
        "warmup_time": -1
    },
    "analysis.rdf.SimpleRdfBench.time_interrdf": {
        "code": "class SimpleRdfBench:\n    def time_interrdf(self, nbins, range_val, natoms):\n        \"\"\"Benchmark a full trajectory parse\n        by MDAnalysis.analysis.rdf.InterRDF\n        \"\"\"\n        self.rdf.run()\n\n    def setup(self, nbins, range_val, natoms):\n    \n        self.sel_str = \"name OW\"\n    \n        self.u = MDAnalysis.Universe(TPR, XTC)\n    \n        try:\n            self.sel = self.u.select_atoms(self.sel_str)[:natoms]\n        except AttributeError:\n            self.sel = self.u.selectAtoms(self.sel_str)[:natoms]\n    \n        # do not include initialization of the\n        # InterRDF object in the benchmark itself\n    \n        self.rdf = InterRDF(g1=self.sel, g2=self.sel, nbins=nbins, range=range_val)",
        "min_run_count": 2,
        "name": "analysis.rdf.SimpleRdfBench.time_interrdf",
        "number": 0,
        "param_names": [
            "nbins",
            "range_val",
            "natoms"
        ],
        "params": [
            [
                "20",
                "75",
                "200"
            ],
            [
                "[0, 5]",
                "[0, 15]",
                "[0, 20]"
            ],
            [
                "1",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "252dd09a8bde12c858192eae3fbd5594cb228c2f298b120246df3d72558b868a",
        "warmup_time": -1
    },
    "analysis.rdf.SimpleRdfsBench.time_interrdfs": {
        "code": "class SimpleRdfsBench:\n    def time_interrdfs(self, nbins, range_val, natoms, npairs):\n        \"\"\"Benchmark a full trajectory parse\n        by MDAnalysis.analysis.rdf.InterRDF_s\n        \"\"\"\n        self.rdf_s.run()\n\n    def setup(self, nbins, range_val, natoms, npairs):\n    \n        self.sel_str = \"name OW\"\n    \n        self.u = MDAnalysis.Universe(TPR, XTC)\n    \n        try:\n            self.sel = self.u.select_atoms(self.sel_str)[:natoms]\n        except AttributeError:\n            self.sel = self.u.selectAtoms(self.sel_str)[:natoms]\n    \n        ags = [[self.sel, self.sel]] * npairs\n        self.rdf_s = InterRDF_s(self.u, ags, nbins=nbins, range=range_val)",
        "min_run_count": 2,
        "name": "analysis.rdf.SimpleRdfsBench.time_interrdfs",
        "number": 0,
        "param_names": [
            "nbins",
            "range_val",
            "natoms",
            "npairs"
        ],
        "params": [
            [
                "20",
                "75",
                "200"
            ],
            [
                "[0, 5]",
                "[0, 15]",
                "[0, 20]"
            ],
            [
                "10",
                "100"
            ],
            [
                "1",
                "3",
                "9"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "6bda027ed48cc69a20d1ed9b8dc0547bc5ad05b285844269385fdc7cd6ffcc21",
        "warmup_time": -1
    },
    "analysis.rms.RmsdTrajBench.time_RMSD": {
        "code": "class RmsdTrajBench:\n    def time_RMSD(self, select, weights):\n        \"\"\"Benchmark RMSD.run() method, which parses\n        over the entire trajectory.\n        \"\"\"\n        self.RMSD_inst.run()\n\n    def setup(self, select, weights):\n        self.u = MDAnalysis.Universe(PSF, DCD)\n        self.RMSD_inst = rms.RMSD(\n            atomgroup=self.u, reference=None, select=select, weights=weights\n        )",
        "min_run_count": 2,
        "name": "analysis.rms.RmsdTrajBench.time_RMSD",
        "number": 0,
        "param_names": [
            "select",
            "weights"
        ],
        "params": [
            [
                "'all'",
                "'backbone'"
            ],
            [
                "None",
                "'mass'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "65958d61bbac1cea9523ebcc97f25bc590629a0e715ff9d5b1a93eff4ed119e1",
        "warmup_time": -1
    },
    "analysis.rms.RmsfTrajBench.time_RMSF": {
        "code": "class RmsfTrajBench:\n    def time_RMSF(self, n_atoms, step, weights):\n        \"\"\"Benchmark RMSF.run() method, which parses\n        over the entire trajectory.\n        \"\"\"\n        self.RMSF_inst.run(step=step)\n\n    def setup(self, n_atoms, step, weights):\n        self.u = MDAnalysis.Universe(PSF, DCD)\n        self.ag = self.u.atoms[:n_atoms]\n        self.RMSF_inst = rms.RMSF(atomgroup=self.ag, weights=weights)",
        "min_run_count": 2,
        "name": "analysis.rms.RmsfTrajBench.time_RMSF",
        "number": 0,
        "param_names": [
            "n_atoms",
            "step",
            "weights"
        ],
        "params": [
            [
                "100",
                "500",
                "2000"
            ],
            [
                "None",
                "3"
            ],
            [
                "None",
                "'mass'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "b8ed669f2294c9a8324cc07a6b76931134ebe3f9c22346b5d72b04f82da5097a",
        "warmup_time": -1
    },
    "analysis.rms.SimpleRmsBench.time_rmsd": {
        "code": "class SimpleRmsBench:\n    def time_rmsd(self, num_atoms, weights, center, superposition):\n        \"\"\"Benchmark rmsd function using a setup similar to\n        its docstring example code along with several possible\n        permutations of parameters.\n        \"\"\"\n        rms.rmsd(\n            a=self.A,\n            b=self.B,\n            weights=self.weights,\n            center=center,\n            superposition=superposition,\n        )\n\n    def setup(self, num_atoms, use_weights, center, superposition):\n        # mimic rmsd docstring example code\n        self.u = MDAnalysis.Universe(PSF, DCD)\n        # ag.positions is the new syntax\n        # but older commit hashes will need to use\n        # ag.coordinates()\n        self.A = self.u.atoms.positions.copy()[:num_atoms]\n        self.u.trajectory[-1]\n        self.B = self.u.atoms.positions.copy()[:num_atoms]\n        self.atoms = self.u.atoms[:num_atoms]\n        self.weights = self.atoms.masses/np.sum(self.atoms.masses) if use_weights else None",
        "min_run_count": 2,
        "name": "analysis.rms.SimpleRmsBench.time_rmsd",
        "number": 0,
        "param_names": [
            "num_atoms",
            "use_weights",
            "center",
            "superposition"
        ],
        "params": [
            [
                "100",
                "500",
                "2000"
            ],
            [
                "True",
                "False"
            ],
            [
                "False",
                "True"
            ],
            [
                "False",
                "True"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "b74eb063f9b3e83a0604f6fdb0c5116a9850f3618cc514e5b82b1f6df9e75e4f",
        "warmup_time": -1
    },
    "import.ImportBench.time_import": {
        "code": "class ImportBench:\n    def time_import(self):\n        \"\"\"Benchmark time needed to import MDAnalysis\"\"\"\n        import MDAnalysis as mda\n    \n        pass",
        "min_run_count": 2,
        "name": "import.ImportBench.time_import",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "5d9e4f4fa2fdddc9a805fe9a2fb4f7d0d7bf46aff2227e88630089f3e2f0a583",
        "warmup_time": -1
    },
    "selections.GeoSelectionBench.time_geometric_selections": {
        "code": "class GeoSelectionBench:\n    def time_geometric_selections(\n        self, selection_string, dynamic_selection, periodic_selection\n    ):\n    \n        # TODO: Do we need a kwarg similar to old `use_KDTree_routines`\n        # flag? We used to benchmark that.\n        self.u.select_atoms(\n            selection_string,\n            updating=dynamic_selection,\n            periodic=periodic_selection[0],\n        )\n\n    def setup(self, selection_string, dynamic_selection, periodic_selection):\n        self.u = MDAnalysis.Universe(GRO)",
        "min_run_count": 2,
        "name": "selections.GeoSelectionBench.time_geometric_selections",
        "number": 0,
        "param_names": [
            "selection_string",
            "dynamic_selection",
            "periodic_selection"
        ],
        "params": [
            [
                "'around 5.0 resid 1'",
                "'sphlayer 2.4 6.0 (protein)'",
                "'sphzone 6.0 (protein)'",
                "'cylayer 5 10 10 -8 protein'",
                "'cyzone 15 4 -8 protein'",
                "'point 5.0 5.0 5.0 3.5'",
                "'prop z >= 5.0'",
                "'prop abs z <= 5.0'"
            ],
            [
                "True",
                "False"
            ],
            [
                "[False, True]",
                "[True, False]"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "36ee86f86213756189fc6d9e073d1fe65be5ac8171223839c96676ecbb3a1b17",
        "warmup_time": -1
    },
    "selections.SimpleSelectionBench.time_simple_selections": {
        "code": "class SimpleSelectionBench:\n    def time_simple_selections(self, selection_string):\n        \"\"\"Benchmark simple selections on the protein-based\n        standard test GRO file.\n        \"\"\"\n        if hasattr(MDAnalysis.Universe, \"select_atoms\"):\n            self.u.select_atoms(selection_string)\n        else:\n            self.u.selectAtoms(selection_string)\n\n    def setup(self, selection_string):\n        self.u = MDAnalysis.Universe(GRO)",
        "min_run_count": 2,
        "name": "selections.SimpleSelectionBench.time_simple_selections",
        "number": 0,
        "param_names": [
            "selection_string"
        ],
        "params": [
            [
                "'protein'",
                "'backbone'",
                "'nucleic'",
                "'nucleicbackbone'",
                "'resid 1:10'",
                "'resnum 1:10'",
                "'resname LYS'",
                "'name CA'",
                "'bynum 0:10'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "c42340fb0265d9a6d0b2df4dde1427aebc6a9f9d01cc75abfa20a7e940799790",
        "warmup_time": -1
    },
    "topology.BondsBench.time_bonds": {
        "code": "class BondsBench:\n    def time_bonds(self, num_bonds):\n        \"\"\"Benchmark for calculating bonds\"\"\"\n        self.u.bonds\n\n    def setup(self, num_bonds):\n        self.u = MDAnalysis.Universe.empty(2 * num_bonds)\n        bonds = np.arange(2 * num_bonds).reshape(num_bonds, 2)\n        self.u.add_bonds(bonds)",
        "min_run_count": 2,
        "name": "topology.BondsBench.time_bonds",
        "number": 0,
        "param_names": [
            "num_bonds"
        ],
        "params": [
            [
                "1000",
                "10000",
                "100000",
                "1000000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "75cad4d0b662214f93076a228cafa4525fc22e07c7ec1e2de760b4ae2129bc33",
        "warmup_time": -1
    },
    "topology.TopologyGuessBench.time_guessbonds": {
        "code": "class TopologyGuessBench:\n    def time_guessbonds(self, num_atoms):\n        \"\"\"Benchmark for guessing bonds\"\"\"\n        DefaultGuesser(None).guess_bonds(\n            self.ag, self.ag.positions, box=self.ag.dimensions, vdwradii=self.vdwradii\n        )\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.vdwradii = {\"H\": 1.0, \"C\": 1.0, \"N\": 1.0, \"O\": 1.0, \"DUMMY\": 1.0}",
        "min_run_count": 2,
        "name": "topology.TopologyGuessBench.time_guessbonds",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "bf5f755b2cede8934aaa5a313bed142dc5d374d4d330a0ed5227ffe20c4b28ad",
        "warmup_time": -1
    },
    "traj_reader.TrajReaderCreation.time_reads": {
        "code": "class TrajReaderCreation:\n    def time_reads(self, traj_format):\n        \"\"\"Simple benchmark for reading traj file formats\n        from our standard test files.\n        \"\"\"\n        self.traj_reader(self.traj_file)\n\n    def setup(self, traj_format):\n        self.traj_dict = traj_dict\n        self.traj_file, self.traj_reader = self.traj_dict[traj_format]",
        "min_run_count": 2,
        "name": "traj_reader.TrajReaderCreation.time_reads",
        "number": 0,
        "param_names": [
            "traj_format"
        ],
        "params": [
            [
                "'XTC'",
                "'TRR'",
                "'DCD'",
                "'NCDF'",
                "'TRC'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "4b030c7c2af116b5eaaec4c77913ed39dda95d0f355f11be9ee99403dfa71f93",
        "warmup_time": -1
    },
    "traj_reader.TrajReaderIteration.time_strides": {
        "code": "class TrajReaderIteration:\n    def time_strides(self, traj_format):\n        \"\"\"Benchmark striding over full trajectory\n        test files for each format.\n        \"\"\"\n        for ts in self.reader_object:\n            pass\n\n    def setup(self, traj_format):\n        self.traj_dict = traj_dict\n        self.traj_file, self.traj_reader = self.traj_dict[traj_format]\n        self.reader_object = self.traj_reader(self.traj_file)",
        "min_run_count": 2,
        "name": "traj_reader.TrajReaderIteration.time_strides",
        "number": 0,
        "param_names": [
            "traj_format"
        ],
        "params": [
            [
                "'XTC'",
                "'TRR'",
                "'DCD'",
                "'NCDF'",
                "'TRC'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "d2890f87c636b5336c33c4ede5c97f90f26b52ea890f4514459dee27de3b92fc",
        "warmup_time": -1
    },
    "version": 2
}