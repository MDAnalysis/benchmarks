{
    "GRO.GROReadBench.time_read_GRO_file": {
        "code": "class GROReadBench:\n    def time_read_GRO_file(self):\n        \"\"\"Benchmark reading of standard test\n        suite GRO file.\n        \"\"\"\n        GROReader(GRO)",
        "goal_time": 0.1,
        "name": "GRO.GROReadBench.time_read_GRO_file",
        "number": 0,
        "param_names": [],
        "params": [],
        "pretty_name": "GRO.GROReadBench.time_read_GRO_file",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "2abb6fac26984d3cc4cee1b56b630a1e89a527336aa1795c49a9dadef130db3e",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupAttrsBench.time_angle": {
        "code": "class AtomGroupAttrsBench:\n    def time_angle(self, num_atoms):\n        \"\"\"Benchmark simple angle\n        calculation. Requires ag\n        with three atoms.\n        \"\"\"\n        self.ag[:3].angle\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]",
        "goal_time": 0.1,
        "name": "ag_methods.AtomGroupAttrsBench.time_angle",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "ag_methods.AtomGroupAttrsBench.time_angle",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "a83a2ce99c0673f57ac3eac16b49a9db026ae64b6fcaa4389bf47eed59124dbb",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupAttrsBench.time_atomcount": {
        "code": "class AtomGroupAttrsBench:\n    def time_atomcount(self, num_atoms):\n        \"\"\"Benchmark counting of atoms in\n        atomgroup.\n        \"\"\"\n        self.ag.n_atoms\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]",
        "goal_time": 0.1,
        "name": "ag_methods.AtomGroupAttrsBench.time_atomcount",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "ag_methods.AtomGroupAttrsBench.time_atomcount",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "d31f8341e31a7bc198133f258c72536b54ec904f97ac4f28a767f9970856818a",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupAttrsBench.time_atoms": {
        "code": "class AtomGroupAttrsBench:\n    def time_atoms(self, num_atoms):\n        \"\"\"Benchmark returning of identical\n        atomgroup.\n        \"\"\"\n        self.ag.atoms\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]",
        "goal_time": 0.1,
        "name": "ag_methods.AtomGroupAttrsBench.time_atoms",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "ag_methods.AtomGroupAttrsBench.time_atoms",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "6cd2f945901dc324d1dabcb388bc3fe0c3b5977d49056e5d7a7859c40e2c9af8",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupAttrsBench.time_bond": {
        "code": "class AtomGroupAttrsBench:\n    def time_bond(self, num_atoms):\n        \"\"\"Benchmark Bond object creation.\n        Requires ag of size 2.\n        \"\"\"\n        self.ag[:2].bond\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]",
        "goal_time": 0.1,
        "name": "ag_methods.AtomGroupAttrsBench.time_bond",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "ag_methods.AtomGroupAttrsBench.time_bond",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "3507b8355b5b01697e086a646c559412d09fde51fc7139f4524f7cb58aa7ae67",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupAttrsBench.time_dihedral": {
        "code": "class AtomGroupAttrsBench:\n    def time_dihedral(self, num_atoms):\n        \"\"\"Benchmark Dihedral object\n        creation time. Requires ag of\n        size 4.\n        \"\"\"\n        self.ag[:4].dihedral\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]",
        "goal_time": 0.1,
        "name": "ag_methods.AtomGroupAttrsBench.time_dihedral",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "ag_methods.AtomGroupAttrsBench.time_dihedral",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "5775f1a2f7666febcc47f94b77702bd75a2a7ccd7c9044265c965dbad779a351",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupAttrsBench.time_forces": {
        "code": "class AtomGroupAttrsBench:\n    def time_forces(self, num_atoms):\n        \"\"\"Benchmark atomgroup force\n        calculation.\n        \"\"\"\n        try:\n            self.ag.forces\n        except NoDataError:\n            pass\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]",
        "goal_time": 0.1,
        "name": "ag_methods.AtomGroupAttrsBench.time_forces",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "ag_methods.AtomGroupAttrsBench.time_forces",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "0186fc73e76b8e3f8cb39e7e11f7c6e9837d800b2379b14591432ee9e710d69e",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupAttrsBench.time_improper": {
        "code": "class AtomGroupAttrsBench:\n    def time_improper(self, num_atoms):\n        \"\"\"Benchmark improper dihedral\n        calculation. Requires ag of size\n        4.\n        \"\"\"\n        self.ag[:4].improper\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]",
        "goal_time": 0.1,
        "name": "ag_methods.AtomGroupAttrsBench.time_improper",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "ag_methods.AtomGroupAttrsBench.time_improper",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "d7ba217b21841225ff1df0b473d66794db6b2c92c56bbb3cb04c042fb43e967c",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupAttrsBench.time_indices": {
        "code": "class AtomGroupAttrsBench:\n    def time_indices(self, num_atoms):\n        \"\"\"Benchmark atom index calculation.\n        \"\"\"\n        self.ag.ix\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]",
        "goal_time": 0.1,
        "name": "ag_methods.AtomGroupAttrsBench.time_indices",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "ag_methods.AtomGroupAttrsBench.time_indices",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "8a27cd7f019ca3f35aa37d112e72f6b0311c37dee14a33adff3dffd8b6ee2602",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupAttrsBench.time_positions": {
        "code": "class AtomGroupAttrsBench:\n    def time_positions(self, num_atoms):\n        \"\"\"Benchmark returning the positions\n        of the atoms in the group.\n        \"\"\"\n        self.ag.positions\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]",
        "goal_time": 0.1,
        "name": "ag_methods.AtomGroupAttrsBench.time_positions",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "ag_methods.AtomGroupAttrsBench.time_positions",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "7f538e5ccf7c68b715cb9ba1f0a85764faa5e09216ba83be3b88804f26504dcd",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupAttrsBench.time_residuecount": {
        "code": "class AtomGroupAttrsBench:\n    def time_residuecount(self, num_atoms):\n        \"\"\"Benchmark counting of residues in\n        atomgroup.\n        \"\"\"\n        self.ag.n_residues\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]",
        "goal_time": 0.1,
        "name": "ag_methods.AtomGroupAttrsBench.time_residuecount",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "ag_methods.AtomGroupAttrsBench.time_residuecount",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "6ba8023af1d40da84022b2eba1e494b20eb80d1257fa5beabc2206f8d380b237",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupAttrsBench.time_residues": {
        "code": "class AtomGroupAttrsBench:\n    def time_residues(self, num_atoms):\n        \"\"\"Benchmark creation of the ResidueGroup\n        from the AtomGroup.\n        \"\"\"\n        self.ag.residues\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]",
        "goal_time": 0.1,
        "name": "ag_methods.AtomGroupAttrsBench.time_residues",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "ag_methods.AtomGroupAttrsBench.time_residues",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "72655f2bf91db254ada1b26646da826894a223384a4691f99b06b291107b938e",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupAttrsBench.time_segmentcount": {
        "code": "class AtomGroupAttrsBench:\n    def time_segmentcount(self, num_atoms):\n        \"\"\"Benchmark counting of segments in\n        atomgroup.\n        \"\"\"\n        self.ag.n_segments\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]",
        "goal_time": 0.1,
        "name": "ag_methods.AtomGroupAttrsBench.time_segmentcount",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "ag_methods.AtomGroupAttrsBench.time_segmentcount",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "ea9ccc59b78a3786c8ed142a014c476162b2d37437c8f93a4b05644dd851aede",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupAttrsBench.time_segments": {
        "code": "class AtomGroupAttrsBench:\n    def time_segments(self, num_atoms):\n        \"\"\"Benchmark determination of sorted\n        SegmentGroup from AtomGroup.\n        \"\"\"\n        self.ag.segments\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]",
        "goal_time": 0.1,
        "name": "ag_methods.AtomGroupAttrsBench.time_segments",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "ag_methods.AtomGroupAttrsBench.time_segments",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "ec21432839b2caac695337844d8b3feff546e74083cc61d846692523160bcf70",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupAttrsBench.time_ts": {
        "code": "class AtomGroupAttrsBench:\n    def time_ts(self, num_atoms):\n        \"\"\"Benchmark returning of a timestep\n        instance from atomgroup.\n        \"\"\"\n        self.ag.ts\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]",
        "goal_time": 0.1,
        "name": "ag_methods.AtomGroupAttrsBench.time_ts",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "ag_methods.AtomGroupAttrsBench.time_ts",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "0aadba3b29a020c1edbc55253049c8f9dc252759321e51f110ca895d99ce52a6",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupAttrsBench.time_unique": {
        "code": "class AtomGroupAttrsBench:\n    def time_unique(self, num_atoms):\n        \"\"\"Benchmark determination of unique\n        elements in atomgroup.\n        \"\"\"\n        self.ag.unique\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]",
        "goal_time": 0.1,
        "name": "ag_methods.AtomGroupAttrsBench.time_unique",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "ag_methods.AtomGroupAttrsBench.time_unique",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "1c2345530d78545ab7011e17420325ec0f2b12a472ade667a7253fd672a06f70",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupAttrsBench.time_velocity": {
        "code": "class AtomGroupAttrsBench:\n    def time_velocity(self, num_atoms):\n        \"\"\"Benchmark atomgroup velocity\n        values return.\n        \"\"\"\n        try:\n            self.ag.velocities\n        except NoDataError:\n            pass\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]",
        "goal_time": 0.1,
        "name": "ag_methods.AtomGroupAttrsBench.time_velocity",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "ag_methods.AtomGroupAttrsBench.time_velocity",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "3841e8cfb0518bdc257c0479f3844b8bdf80ee1e2bf7b2245ba4ba95533e2ce8",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_bbox_no_pbc": {
        "code": "class AtomGroupMethodsBench:\n    def time_bbox_no_pbc(self, num_atoms):\n        \"\"\"Benchmark bounding box calculation\n        with pbc inactive.\n        \"\"\"\n        self.ag.bbox(pbc=False)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'NA':1.0,\n                         'M':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "goal_time": 0.1,
        "name": "ag_methods.AtomGroupMethodsBench.time_bbox_no_pbc",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "ag_methods.AtomGroupMethodsBench.time_bbox_no_pbc",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "b13f09f921e8d1b3547c3ae8fd0cb3b4fba4746e2535728f647b28e2d39e8771",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_bbox_pbc": {
        "code": "class AtomGroupMethodsBench:\n    def time_bbox_pbc(self, num_atoms):\n        \"\"\"Benchmark bounding box calculation\n        with pbc active.\n        \"\"\"\n        self.ag.bbox(pbc=True)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'NA':1.0,\n                         'M':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "goal_time": 0.1,
        "name": "ag_methods.AtomGroupMethodsBench.time_bbox_pbc",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "ag_methods.AtomGroupMethodsBench.time_bbox_pbc",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "a18324c53c11b7aa21428889531395b23a6ed680df364d8870cf805125985b04",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_bsphere_no_pbc": {
        "code": "class AtomGroupMethodsBench:\n    def time_bsphere_no_pbc(self, num_atoms):\n        \"\"\"Benchmark bounding sphere calculation\n        with pbc inactive.\n        \"\"\"\n        self.ag.bsphere(pbc=False)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'NA':1.0,\n                         'M':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "goal_time": 0.1,
        "name": "ag_methods.AtomGroupMethodsBench.time_bsphere_no_pbc",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "ag_methods.AtomGroupMethodsBench.time_bsphere_no_pbc",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "462159b20c380fd2a72f198e059dd75a604e2ad5251253524c7ee78f59b8d4a1",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_bsphere_pbc": {
        "code": "class AtomGroupMethodsBench:\n    def time_bsphere_pbc(self, num_atoms):\n        \"\"\"Benchmark bounding sphere calculation\n        with pbc active.\n        \"\"\"\n        self.ag.bsphere(pbc=True)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'NA':1.0,\n                         'M':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "goal_time": 0.1,
        "name": "ag_methods.AtomGroupMethodsBench.time_bsphere_pbc",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "ag_methods.AtomGroupMethodsBench.time_bsphere_pbc",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "ca1199ef4aafadf534247b69dee706f1a509faccffab75deb23a743f3bc5e39f",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_center_no_pbc": {
        "code": "class AtomGroupMethodsBench:\n    def time_center_no_pbc(self, num_atoms):\n        \"\"\"Benchmark center calculation with\n        pbc inactive.\n        \"\"\"\n        self.ag.center(weights=self.weights,\n                       pbc=False)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'NA':1.0,\n                         'M':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "goal_time": 0.1,
        "name": "ag_methods.AtomGroupMethodsBench.time_center_no_pbc",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "ag_methods.AtomGroupMethodsBench.time_center_no_pbc",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "a33f50328490f6b54e8ad57796bd6da48ce81e2af1d6ff7b6dc9ddb55270d612",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_center_pbc": {
        "code": "class AtomGroupMethodsBench:\n    def time_center_pbc(self, num_atoms):\n        \"\"\"Benchmark center calculation with\n        pbc active.\n        \"\"\"\n        self.ag.center(weights=self.weights,\n                       pbc=True)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'NA':1.0,\n                         'M':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "goal_time": 0.1,
        "name": "ag_methods.AtomGroupMethodsBench.time_center_pbc",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "ag_methods.AtomGroupMethodsBench.time_center_pbc",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "5445ea28992842878e2e020cb920daa4b87f10ea68ba6abbdc379e69ecd29a5a",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_centroid_no_pbc": {
        "code": "class AtomGroupMethodsBench:\n    def time_centroid_no_pbc(self, num_atoms):\n        \"\"\"Benchmark centroid calculation with\n        pbc inactive.\n        \"\"\"\n        self.ag.centroid(pbc=False)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'NA':1.0,\n                         'M':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "goal_time": 0.1,
        "name": "ag_methods.AtomGroupMethodsBench.time_centroid_no_pbc",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "ag_methods.AtomGroupMethodsBench.time_centroid_no_pbc",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f941f327f6692f250060de8e3de49f414db194f030fa2f2e86b50a96f3d6f580",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_centroid_pbc": {
        "code": "class AtomGroupMethodsBench:\n    def time_centroid_pbc(self, num_atoms):\n        \"\"\"Benchmark centroid calculation with\n        pbc active.\n        \"\"\"\n        self.ag.centroid(pbc=True)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'NA':1.0,\n                         'M':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "goal_time": 0.1,
        "name": "ag_methods.AtomGroupMethodsBench.time_centroid_pbc",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "ag_methods.AtomGroupMethodsBench.time_centroid_pbc",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "94e61928db6101dcb12bef8d8f0c21cc8e8eb805ddf2abd0096fa60dd6fda1a5",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_concatenate": {
        "code": "class AtomGroupMethodsBench:\n    def time_concatenate(self, num_atoms):\n        \"\"\"Benchmark atomgroup concatenation.\n        \"\"\"\n        self.ag.concatenate(self.ag)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'NA':1.0,\n                         'M':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "goal_time": 0.1,
        "name": "ag_methods.AtomGroupMethodsBench.time_concatenate",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "ag_methods.AtomGroupMethodsBench.time_concatenate",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "08fff968d2569e3c626ab3f36d271b3cf297135df1817dc29466a74e9c5d5965",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_difference": {
        "code": "class AtomGroupMethodsBench:\n    def time_difference(self, num_atoms):\n        \"\"\"Benchmark atomgroup difference\n        operation.\n        \"\"\"\n        self.ag.difference(self.ag)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'NA':1.0,\n                         'M':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "goal_time": 0.1,
        "name": "ag_methods.AtomGroupMethodsBench.time_difference",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "ag_methods.AtomGroupMethodsBench.time_difference",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "8f0b13fd7cae0a5a7a8cc9e415a0c6d58230410e7b84d4e74eb3fa8cdd4adf18",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_groupby": {
        "code": "class AtomGroupMethodsBench:\n    def time_groupby(self, num_atoms):\n        \"\"\"Benchmark atomgroup groupby\n        operation.\n        \"\"\"\n        self.ag.groupby('resnames')\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'NA':1.0,\n                         'M':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "goal_time": 0.1,
        "name": "ag_methods.AtomGroupMethodsBench.time_groupby",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "ag_methods.AtomGroupMethodsBench.time_groupby",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "109267e4cf4a02b7e4460ce5e1de2eebaeadc77610a858512167fb377d68d212",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_guess_bonds": {
        "code": "class AtomGroupMethodsBench:\n    def time_guess_bonds(self, num_atoms):\n        \"\"\"Benchmark atomgroup bond guessing\n        with artificially-seeded vdw values.\n        \"\"\"\n        self.ag.guess_bonds(self.vdwradii)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'NA':1.0,\n                         'M':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "goal_time": 0.1,
        "name": "ag_methods.AtomGroupMethodsBench.time_guess_bonds",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "ag_methods.AtomGroupMethodsBench.time_guess_bonds",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "95b590f48cef5cb4b4cc65ecb884482e1df985417494daba2225ba8bd2bf8b88",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_intersection": {
        "code": "class AtomGroupMethodsBench:\n    def time_intersection(self, num_atoms):\n        \"\"\"Benchmark ag intersection.\n        \"\"\"\n        self.ag.intersection(self.ag)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'NA':1.0,\n                         'M':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "goal_time": 0.1,
        "name": "ag_methods.AtomGroupMethodsBench.time_intersection",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "ag_methods.AtomGroupMethodsBench.time_intersection",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "3007281b5a990c40e16f4d638bc27d207c0121ee4ae2bd559535e139906a7116",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_is_strict_subset": {
        "code": "class AtomGroupMethodsBench:\n    def time_is_strict_subset(self, num_atoms):\n        \"\"\"Benchmark ag strict subset operation.\n        \"\"\"\n        self.ag.is_strict_subset(self.ag)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'NA':1.0,\n                         'M':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "goal_time": 0.1,
        "name": "ag_methods.AtomGroupMethodsBench.time_is_strict_subset",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "ag_methods.AtomGroupMethodsBench.time_is_strict_subset",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "07a48244c719831d730836e0d632ea051837548e8dcebf489cf83a7434fd3c70",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_is_strict_superset": {
        "code": "class AtomGroupMethodsBench:\n    def time_is_strict_superset(self, num_atoms):\n        \"\"\"Benchmark ag strict superset operation.\n        \"\"\"\n        self.ag.is_strict_superset(self.ag)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'NA':1.0,\n                         'M':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "goal_time": 0.1,
        "name": "ag_methods.AtomGroupMethodsBench.time_is_strict_superset",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "ag_methods.AtomGroupMethodsBench.time_is_strict_superset",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "4509e22682291b68212a7d28d543479cf0eb06e2bdf24f4b1e56fcd101de33c4",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_isdisjoint": {
        "code": "class AtomGroupMethodsBench:\n    def time_isdisjoint(self, num_atoms):\n        \"\"\"Benchmark disjoint operation between\n        atomgroups.\n        \"\"\"\n        self.ag.isdisjoint(self.ag)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'NA':1.0,\n                         'M':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "goal_time": 0.1,
        "name": "ag_methods.AtomGroupMethodsBench.time_isdisjoint",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "ag_methods.AtomGroupMethodsBench.time_isdisjoint",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "e820b56a4be332d95e85ffda08a25081a5804ae36c99d49e47944fe7ef0681f0",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_issubset": {
        "code": "class AtomGroupMethodsBench:\n    def time_issubset(self, num_atoms):\n        \"\"\"Benchmark subset operation between\n        atomgroups.\n        \"\"\"\n        self.ag.issubset(self.ag)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'NA':1.0,\n                         'M':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "goal_time": 0.1,
        "name": "ag_methods.AtomGroupMethodsBench.time_issubset",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "ag_methods.AtomGroupMethodsBench.time_issubset",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "d7d2fb1a556412daacc0591250615f8f4edd560ddce907bc37b152119592510a",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_issuperset": {
        "code": "class AtomGroupMethodsBench:\n    def time_issuperset(self, num_atoms):\n        \"\"\"Benchmark superset operation between\n        atomgroups.\n        \"\"\"\n        self.ag.issuperset(self.ag)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'NA':1.0,\n                         'M':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "goal_time": 0.1,
        "name": "ag_methods.AtomGroupMethodsBench.time_issuperset",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "ag_methods.AtomGroupMethodsBench.time_issuperset",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "da1b751a6ac0b844aafb5acb4524b855af9ac6d19a85e3bfe3aa5c7c584e1073",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_pack_into_box": {
        "code": "class AtomGroupMethodsBench:\n    def time_pack_into_box(self, num_atoms):\n        \"\"\"Benchmark shifting atoms of ag\n        into primary unit cell, using\n        default parameters.\n        \"\"\"\n        self.ag.pack_into_box()\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'NA':1.0,\n                         'M':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "goal_time": 0.1,
        "name": "ag_methods.AtomGroupMethodsBench.time_pack_into_box",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "ag_methods.AtomGroupMethodsBench.time_pack_into_box",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "20dcad012b1c84cac6934e6c4589008df0db8dc5bed3d9634f6420e378f4d4a5",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_rotate": {
        "code": "class AtomGroupMethodsBench:\n    def time_rotate(self, num_atoms):\n        \"\"\"Benchmark simple rotation operation\n        on atomgroup.\n        \"\"\"\n        self.ag.rotate(self.rot_matrix)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'NA':1.0,\n                         'M':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "goal_time": 0.1,
        "name": "ag_methods.AtomGroupMethodsBench.time_rotate",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "ag_methods.AtomGroupMethodsBench.time_rotate",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "4fcd69bfa4ccdcf7ec26b4668d209c0f68fb3fa1cd5ca45bd420ba21ebec4f50",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_rotateby": {
        "code": "class AtomGroupMethodsBench:\n    def time_rotateby(self, num_atoms):\n        \"\"\"Benchmark rotation by an angle\n        of the ag coordinates.\n        \"\"\"\n        self.ag.rotateby(angle=45,\n                         axis=[1,0,0])\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'NA':1.0,\n                         'M':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "goal_time": 0.1,
        "name": "ag_methods.AtomGroupMethodsBench.time_rotateby",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "ag_methods.AtomGroupMethodsBench.time_rotateby",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "148d833401af66968dc752ff9a891a57a372b0ba8491e3abbec882424c940a5c",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_split": {
        "code": "class AtomGroupMethodsBench:\n    def time_split(self, num_atoms):\n        \"\"\"Benchmark ag splitting into\n        multiple ags based on a simple\n        criterion.\n        \"\"\"\n        self.ag.split('residue')\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'NA':1.0,\n                         'M':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "goal_time": 0.1,
        "name": "ag_methods.AtomGroupMethodsBench.time_split",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "ag_methods.AtomGroupMethodsBench.time_split",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "2d9fbbd08120214f9a6c21a4399c753bbf34baf01a5272e3e0bd5ce83ccab090",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_subtract": {
        "code": "class AtomGroupMethodsBench:\n    def time_subtract(self, num_atoms):\n        \"\"\"Benchmark ag subtraction.\n        \"\"\"\n        self.ag.subtract(self.ag)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'NA':1.0,\n                         'M':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "goal_time": 0.1,
        "name": "ag_methods.AtomGroupMethodsBench.time_subtract",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "ag_methods.AtomGroupMethodsBench.time_subtract",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "78fb61b55cffa02e23f514737586a4d9dbac9c7a0e817f7c6b461187b2c7698d",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_symmetric_difference": {
        "code": "class AtomGroupMethodsBench:\n    def time_symmetric_difference(self, num_atoms):\n        \"\"\"Benchmark ag symmetric difference\n        operation.\n        \"\"\"\n        self.ag.symmetric_difference(self.ag)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'NA':1.0,\n                         'M':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "goal_time": 0.1,
        "name": "ag_methods.AtomGroupMethodsBench.time_symmetric_difference",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "ag_methods.AtomGroupMethodsBench.time_symmetric_difference",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "4bd141ea906565a91d77df06f55db7973acab6c8489d4a325a0230dd53e008e1",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_transform": {
        "code": "class AtomGroupMethodsBench:\n    def time_transform(self, num_atoms):\n        \"\"\"Benchmark application of transformation\n        matrix to atomgroup.\n        \"\"\"\n        self.ag.transform(self.trans)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'NA':1.0,\n                         'M':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "goal_time": 0.1,
        "name": "ag_methods.AtomGroupMethodsBench.time_transform",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "ag_methods.AtomGroupMethodsBench.time_transform",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "71a463da6e9b33d39b18282bdbc7a2923e6222ea434ddf4ef6c81338cc2cf179",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_translate": {
        "code": "class AtomGroupMethodsBench:\n    def time_translate(self, num_atoms):\n        \"\"\"Benchmark the application of a\n        translation vector to the ag\n        coordinates.\n        \"\"\"\n        self.ag.translate([0,0.5,1])\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'NA':1.0,\n                         'M':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "goal_time": 0.1,
        "name": "ag_methods.AtomGroupMethodsBench.time_translate",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "ag_methods.AtomGroupMethodsBench.time_translate",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "701b2a4a83979b7aa99188328321c315dcacc0d96f8c782dd77eb30508672aad",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_union": {
        "code": "class AtomGroupMethodsBench:\n    def time_union(self, num_atoms):\n        \"\"\"Benchmark union operation\n        on atomgroups.\n        \"\"\"\n        self.ag.union(self.ag)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'NA':1.0,\n                         'M':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "goal_time": 0.1,
        "name": "ag_methods.AtomGroupMethodsBench.time_union",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "ag_methods.AtomGroupMethodsBench.time_union",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "bb3896f567a32ad58d0d73819b4d7dd7ad21cd6c2259afd9024b100091b85af0",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_wrap": {
        "code": "class AtomGroupMethodsBench:\n    def time_wrap(self, num_atoms):\n        \"\"\"Benchmark wrap() operation on\n        atomgroup with default params.\n        \"\"\"\n        self.ag.wrap()\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'NA':1.0,\n                         'M':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "goal_time": 0.1,
        "name": "ag_methods.AtomGroupMethodsBench.time_wrap",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "ag_methods.AtomGroupMethodsBench.time_wrap",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "e7da7812425a7b20268e756fc12f62bd501c3a328ebdaebb8b373cc1fea3363c",
        "warmup_time": -1
    },
    "analysis.distances.DistancesBench.time_between": {
        "code": "class DistancesBench:\n    def time_between(self, num_atoms):\n        \"\"\"Benchmark determination of subgroup\n        of atomgroup that is within a specific\n        distance of two other atomgroups.\n        \"\"\"\n        distances.between(group=self.ag3,\n                          A=self.ag1,\n                          B=self.ag2,\n                          distance=15.0)\n\n    def setup(self, num_atoms):\n        np.random.seed(17809)\n        self.coords_1 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(9008716)\n        self.coords_2 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        self.allocated_array_2D = np.empty((num_atoms, num_atoms),\n                                            dtype=np.float64)\n        self.array_shape_1D = int(num_atoms * (num_atoms - 1) / 2.)\n        self.allocated_array_1D = np.empty(self.array_shape_1D,\n                                           dtype=np.float64)\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag1 = self.u.atoms[:num_atoms]\n        self.ag2 = self.u.atoms[num_atoms: 2 * num_atoms]\n        self.ag3 = self.u.atoms[-num_atoms:]",
        "goal_time": 0.1,
        "name": "analysis.distances.DistancesBench.time_between",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "analysis.distances.DistancesBench.time_between",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "eb885148f4da07fe9037d6f5c72f6730a0389638e247a928686fcbd8a19214da",
        "warmup_time": -1
    },
    "analysis.distances.DistancesBench.time_contact_matrix": {
        "code": "class DistancesBench:\n    def time_contact_matrix(self, num_atoms):\n        \"\"\"Benchmark calculation of contacts within\n        a single numpy array using the default arguments\n        to contact_matrix.\n        \"\"\"\n        distances.contact_matrix(coord=self.coords_1,\n                                 cutoff=15.0,\n                                 returntype='numpy',\n                                 box=None)\n\n    def setup(self, num_atoms):\n        np.random.seed(17809)\n        self.coords_1 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(9008716)\n        self.coords_2 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        self.allocated_array_2D = np.empty((num_atoms, num_atoms),\n                                            dtype=np.float64)\n        self.array_shape_1D = int(num_atoms * (num_atoms - 1) / 2.)\n        self.allocated_array_1D = np.empty(self.array_shape_1D,\n                                           dtype=np.float64)\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag1 = self.u.atoms[:num_atoms]\n        self.ag2 = self.u.atoms[num_atoms: 2 * num_atoms]\n        self.ag3 = self.u.atoms[-num_atoms:]",
        "goal_time": 0.1,
        "name": "analysis.distances.DistancesBench.time_contact_matrix",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "analysis.distances.DistancesBench.time_contact_matrix",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "6e4d4f50f6cb85908c188ebfd6de7c40fa3d3df6afef146e01518c709445ccd0",
        "warmup_time": -1
    },
    "analysis.distances.DistancesBench.time_contact_matrix_sparse": {
        "code": "class DistancesBench:\n    def time_contact_matrix_sparse(self, num_atoms):\n        \"\"\"Benchmark calculation of contacts within\n        a single numpy array using the slower reduced\n        memory implementation of contact_matrix intended\n        for larger systems.\n        \"\"\"\n        distances.contact_matrix(coord=self.coords_1,\n                                 cutoff=15.0,\n                                 returntype='sparse',\n                                 box=None)\n\n    def setup(self, num_atoms):\n        np.random.seed(17809)\n        self.coords_1 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(9008716)\n        self.coords_2 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        self.allocated_array_2D = np.empty((num_atoms, num_atoms),\n                                            dtype=np.float64)\n        self.array_shape_1D = int(num_atoms * (num_atoms - 1) / 2.)\n        self.allocated_array_1D = np.empty(self.array_shape_1D,\n                                           dtype=np.float64)\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag1 = self.u.atoms[:num_atoms]\n        self.ag2 = self.u.atoms[num_atoms: 2 * num_atoms]\n        self.ag3 = self.u.atoms[-num_atoms:]",
        "goal_time": 0.1,
        "name": "analysis.distances.DistancesBench.time_contact_matrix_sparse",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "analysis.distances.DistancesBench.time_contact_matrix_sparse",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "4e6d14cd551f572db95de56c5260a5490105139c9c439440473639dcac59bf56",
        "warmup_time": -1
    },
    "analysis.distances.DistancesBench.time_dist": {
        "code": "class DistancesBench:\n    def time_dist(self, num_atoms):\n        \"\"\"Benchmark calculation of distances between\n        atoms in two atomgroups with no offsets\n        to resids.\n        \"\"\"\n        distances.dist(A=self.ag1,\n                       B=self.ag2,\n                       offset=0)\n\n    def setup(self, num_atoms):\n        np.random.seed(17809)\n        self.coords_1 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(9008716)\n        self.coords_2 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        self.allocated_array_2D = np.empty((num_atoms, num_atoms),\n                                            dtype=np.float64)\n        self.array_shape_1D = int(num_atoms * (num_atoms - 1) / 2.)\n        self.allocated_array_1D = np.empty(self.array_shape_1D,\n                                           dtype=np.float64)\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag1 = self.u.atoms[:num_atoms]\n        self.ag2 = self.u.atoms[num_atoms: 2 * num_atoms]\n        self.ag3 = self.u.atoms[-num_atoms:]",
        "goal_time": 0.1,
        "name": "analysis.distances.DistancesBench.time_dist",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "analysis.distances.DistancesBench.time_dist",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "1e316d102d15001127985bbeadcda61a289f6b0c49edf8beb7c8ac292fc70883",
        "warmup_time": -1
    },
    "analysis.distances.DistancesBench.time_dist_offsets": {
        "code": "class DistancesBench:\n    def time_dist_offsets(self, num_atoms):\n        \"\"\"Benchmark calculation of distances between\n        atoms in two atomgroups with offsets\n        to resids.\n        \"\"\"\n        distances.dist(A=self.ag1,\n                       B=self.ag2,\n                       offset=20)\n\n    def setup(self, num_atoms):\n        np.random.seed(17809)\n        self.coords_1 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(9008716)\n        self.coords_2 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        self.allocated_array_2D = np.empty((num_atoms, num_atoms),\n                                            dtype=np.float64)\n        self.array_shape_1D = int(num_atoms * (num_atoms - 1) / 2.)\n        self.allocated_array_1D = np.empty(self.array_shape_1D,\n                                           dtype=np.float64)\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag1 = self.u.atoms[:num_atoms]\n        self.ag2 = self.u.atoms[num_atoms: 2 * num_atoms]\n        self.ag3 = self.u.atoms[-num_atoms:]",
        "goal_time": 0.1,
        "name": "analysis.distances.DistancesBench.time_dist_offsets",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "analysis.distances.DistancesBench.time_dist_offsets",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "0766fec1b0ea981f2f91bc7b592c2c7faa4c27e5821747d0e3f7f27ad30f22e6",
        "warmup_time": -1
    },
    "analysis.distances.DistancesBench.time_distance_array": {
        "code": "class DistancesBench:\n    def time_distance_array(self, num_atoms):\n        \"\"\"Benchmark calculation of all distances\n        between two numpy arrays of coordinates,\n        using default arguments to distance_array.\n        \"\"\"\n        distances.distance_array(reference=self.coords_1,\n                                 configuration=self.coords_2,\n                                 box=None,\n                                 result=None,\n                                 backend='serial')\n\n    def setup(self, num_atoms):\n        np.random.seed(17809)\n        self.coords_1 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(9008716)\n        self.coords_2 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        self.allocated_array_2D = np.empty((num_atoms, num_atoms),\n                                            dtype=np.float64)\n        self.array_shape_1D = int(num_atoms * (num_atoms - 1) / 2.)\n        self.allocated_array_1D = np.empty(self.array_shape_1D,\n                                           dtype=np.float64)\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag1 = self.u.atoms[:num_atoms]\n        self.ag2 = self.u.atoms[num_atoms: 2 * num_atoms]\n        self.ag3 = self.u.atoms[-num_atoms:]",
        "goal_time": 0.1,
        "name": "analysis.distances.DistancesBench.time_distance_array",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "analysis.distances.DistancesBench.time_distance_array",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "6b47aceaee90f91587947029fdaef396adac215eb2ef3057c85f9e410a3e5fa7",
        "warmup_time": -1
    },
    "analysis.distances.DistancesBench.time_distance_array_pre_allocated": {
        "code": "class DistancesBench:\n    def time_distance_array_pre_allocated(self, num_atoms):\n        \"\"\"Benchmark calculation of all distances\n        between two numpy arrays of coordinates,\n        using distance_array with a preallocated\n        result array.\n        \"\"\"\n        distances.distance_array(reference=self.coords_1,\n                                 configuration=self.coords_2,\n                                 box=None,\n                                 result=self.allocated_array_2D,\n                                 backend='serial')\n\n    def setup(self, num_atoms):\n        np.random.seed(17809)\n        self.coords_1 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(9008716)\n        self.coords_2 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        self.allocated_array_2D = np.empty((num_atoms, num_atoms),\n                                            dtype=np.float64)\n        self.array_shape_1D = int(num_atoms * (num_atoms - 1) / 2.)\n        self.allocated_array_1D = np.empty(self.array_shape_1D,\n                                           dtype=np.float64)\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag1 = self.u.atoms[:num_atoms]\n        self.ag2 = self.u.atoms[num_atoms: 2 * num_atoms]\n        self.ag3 = self.u.atoms[-num_atoms:]",
        "goal_time": 0.1,
        "name": "analysis.distances.DistancesBench.time_distance_array_pre_allocated",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "analysis.distances.DistancesBench.time_distance_array_pre_allocated",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "3988cf77ee5eccd5483b603b31c7c25b63f73aa81b757689f2c8bdd9f062ae82",
        "warmup_time": -1
    },
    "analysis.distances.DistancesBench.time_self_distance_array": {
        "code": "class DistancesBench:\n    def time_self_distance_array(self, num_atoms):\n        \"\"\"Benchmark calculation of all distances\n        within a single numpy array of coordinates\n        using default parameters to self_distance_array.\n        \"\"\"\n        distances.self_distance_array(reference=self.coords_1,\n                                      box=None,\n                                      result=None,\n                                      backend='serial')\n\n    def setup(self, num_atoms):\n        np.random.seed(17809)\n        self.coords_1 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(9008716)\n        self.coords_2 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        self.allocated_array_2D = np.empty((num_atoms, num_atoms),\n                                            dtype=np.float64)\n        self.array_shape_1D = int(num_atoms * (num_atoms - 1) / 2.)\n        self.allocated_array_1D = np.empty(self.array_shape_1D,\n                                           dtype=np.float64)\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag1 = self.u.atoms[:num_atoms]\n        self.ag2 = self.u.atoms[num_atoms: 2 * num_atoms]\n        self.ag3 = self.u.atoms[-num_atoms:]",
        "goal_time": 0.1,
        "name": "analysis.distances.DistancesBench.time_self_distance_array",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "analysis.distances.DistancesBench.time_self_distance_array",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "c6dbef3ff4b6c03b07405740d628a4dbd6c5e558b910137a157196ed94020286",
        "warmup_time": -1
    },
    "analysis.distances.DistancesBench.time_self_distance_array_pre_allocated": {
        "code": "class DistancesBench:\n    def time_self_distance_array_pre_allocated(self, num_atoms):\n        \"\"\"Benchmark calculation of all distances\n        within a single numpy array of coordinates\n        using self_distance_array with preallocated\n        result array.\n        \"\"\"\n        distances.self_distance_array(reference=self.coords_1,\n                                      box=None,\n                                      result=self.allocated_array_1D,\n                                      backend='serial')\n\n    def setup(self, num_atoms):\n        np.random.seed(17809)\n        self.coords_1 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(9008716)\n        self.coords_2 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        self.allocated_array_2D = np.empty((num_atoms, num_atoms),\n                                            dtype=np.float64)\n        self.array_shape_1D = int(num_atoms * (num_atoms - 1) / 2.)\n        self.allocated_array_1D = np.empty(self.array_shape_1D,\n                                           dtype=np.float64)\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag1 = self.u.atoms[:num_atoms]\n        self.ag2 = self.u.atoms[num_atoms: 2 * num_atoms]\n        self.ag3 = self.u.atoms[-num_atoms:]",
        "goal_time": 0.1,
        "name": "analysis.distances.DistancesBench.time_self_distance_array_pre_allocated",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "pretty_name": "analysis.distances.DistancesBench.time_self_distance_array_pre_allocated",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "252de8a508db72096fb84cad267be871be5133ab5e2a35ea5b1dbf4d610c3f4e",
        "warmup_time": -1
    },
    "selections.GeoSelectionBench.time_geometric_selections": {
        "code": "class GeoSelectionBench:\n    def time_geometric_selections(self,\n                                  selection_string,\n                                  dynamic_selection,\n                                  periodic_selection):\n    \n        # set core flags for PBC accounting\n        MDAnalysis.core.flags['use_periodic_selections'] = periodic_selection[0]\n        MDAnalysis.core.flags['use_KDTree_routines'] = periodic_selection[1]\n    \n        if hasattr(MDAnalysis.Universe, 'select_atoms'):\n            self.u.select_atoms(selection_string, updating=dynamic_selection)\n        else:\n            self.u.selectAtoms(selection_string, updating=dynamic_selection)\n\n    def setup(self,\n              selection_string,\n              dynamic_selection,\n              periodic_selection):\n        self.u = MDAnalysis.Universe(GRO)",
        "goal_time": 0.1,
        "name": "selections.GeoSelectionBench.time_geometric_selections",
        "number": 0,
        "param_names": [
            "selection_string",
            "dynamic_selection",
            "periodic_selection"
        ],
        "params": [
            [
                "'around 5.0 resid 1'",
                "'sphlayer 2.4 6.0 (protein)'",
                "'sphzone 6.0 (protein)'",
                "'cylayer 5 10 10 -8 protein'",
                "'cyzone 15 4 -8 protein'",
                "'point 5.0 5.0 5.0 3.5'",
                "'prop z >= 5.0'",
                "'prop abs z <= 5.0'"
            ],
            [
                "True",
                "False"
            ],
            [
                "[False, True]",
                "[True, False]"
            ]
        ],
        "pretty_name": "selections.GeoSelectionBench.time_geometric_selections",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "b1d29e5a574daee7de2e1c37536258165a3371b550cd29fc2f41c55e796001e1",
        "warmup_time": -1
    },
    "selections.SimpleSelectionBench.time_simple_selections": {
        "code": "class SimpleSelectionBench:\n    def time_simple_selections(self, selection_string):\n        \"\"\"Benchmark simple selections on the protein-based\n        standard test GRO file.\n        \"\"\"\n        if hasattr(MDAnalysis.Universe, 'select_atoms'):\n            self.u.select_atoms(selection_string)\n        else:\n            self.u.selectAtoms(selection_string)\n\n    def setup(self, selection_string):\n        self.u = MDAnalysis.Universe(GRO)",
        "goal_time": 0.1,
        "name": "selections.SimpleSelectionBench.time_simple_selections",
        "number": 0,
        "param_names": [
            "selection_string"
        ],
        "params": [
            [
                "'protein'",
                "'backbone'",
                "'nucleic'",
                "'nucleicbackbone'",
                "'resid 1:10'",
                "'resnum 1:10'",
                "'resname LYS'",
                "'name CA'",
                "'bynum 0:10'"
            ]
        ],
        "pretty_name": "selections.SimpleSelectionBench.time_simple_selections",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "3d7336e8388a8daf7d76bc3faec4ee662f2ddce17529d2b322ec539be91758c3",
        "warmup_time": -1
    },
    "traj_reader.TrajReaderCreation.time_reads": {
        "code": "class TrajReaderCreation:\n    def time_reads(self, traj_format):\n        \"\"\"Simple benchmark for reading traj file formats\n        from our standard test files.\n        \"\"\"\n        self.traj_reader(self.traj_file)\n\n    def setup(self, traj_format):\n        self.traj_dict = traj_dict\n        self.traj_file, self.traj_reader = self.traj_dict[traj_format]",
        "goal_time": 0.1,
        "name": "traj_reader.TrajReaderCreation.time_reads",
        "number": 0,
        "param_names": [
            "traj_format"
        ],
        "params": [
            [
                "'XTC'",
                "'TRR'",
                "'DCD'",
                "'NCDF'"
            ]
        ],
        "pretty_name": "traj_reader.TrajReaderCreation.time_reads",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "4b030c7c2af116b5eaaec4c77913ed39dda95d0f355f11be9ee99403dfa71f93",
        "warmup_time": -1
    },
    "traj_reader.TrajReaderIteration.time_strides": {
        "code": "class TrajReaderIteration:\n    def time_strides(self, traj_format):\n        \"\"\"Benchmark striding over full trajectory\n        test files for each format.\n        \"\"\"\n        for ts in self.reader_object:\n            pass\n\n    def setup(self, traj_format):\n        self.traj_dict = traj_dict\n        self.traj_file, self.traj_reader = self.traj_dict[traj_format]\n        self.reader_object = self.traj_reader(self.traj_file)",
        "goal_time": 0.1,
        "name": "traj_reader.TrajReaderIteration.time_strides",
        "number": 0,
        "param_names": [
            "traj_format"
        ],
        "params": [
            [
                "'XTC'",
                "'TRR'",
                "'DCD'",
                "'NCDF'"
            ]
        ],
        "pretty_name": "traj_reader.TrajReaderIteration.time_strides",
        "repeat": 0,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "d2890f87c636b5336c33c4ede5c97f90f26b52ea890f4514459dee27de3b92fc",
        "warmup_time": -1
    },
    "version": 1
}