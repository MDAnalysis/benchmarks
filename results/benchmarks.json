{
    "GRO.GROReadBench.time_create_GRO_universe": {
        "code": "class GROReadBench:\n    def time_create_GRO_universe(self):\n        \"\"\"Time to create MDA Universe of GRO\"\"\"\n        u = mda.Universe(GRO)",
        "name": "GRO.GROReadBench.time_create_GRO_universe",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "85e9386a1154d866631322425b43e682903a28a89efb74527110189dcbd24a4a",
        "warmup_time": -1
    },
    "GRO.GROReadBench.time_parse_GRO_file": {
        "code": "class GROReadBench:\n    def time_parse_GRO_file(self):\n        \"\"\"Time to create topology from GRO file\"\"\"\n        p = GROParser(GRO)\n        top = p.parse()",
        "name": "GRO.GROReadBench.time_parse_GRO_file",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "7d0bec284a3cc88727c887e20b4d7a7a6fb3dc8b9a3fed98a8bee728f5920227",
        "warmup_time": -1
    },
    "GRO.GROReadBench.time_read_GRO_coordinates": {
        "code": "class GROReadBench:\n    def time_read_GRO_coordinates(self):\n        \"\"\"Benchmark reading of standard testsuite GRO file.\"\"\"\n        GROReader(GRO)",
        "name": "GRO.GROReadBench.time_read_GRO_coordinates",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "987e7a4b2431ce8645e1a4d7c1135f76c9b35e5eb29b0f6818860f96531be147",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupAttrsBench.time_angle": {
        "code": "class AtomGroupAttrsBench:\n    def time_angle(self, num_atoms):\n        \"\"\"Benchmark simple angle\n        calculation. Requires ag\n        with three atoms.\n        \"\"\"\n        self.ag[:3].angle\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]",
        "name": "ag_methods.AtomGroupAttrsBench.time_angle",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "a83a2ce99c0673f57ac3eac16b49a9db026ae64b6fcaa4389bf47eed59124dbb",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupAttrsBench.time_atomcount": {
        "code": "class AtomGroupAttrsBench:\n    def time_atomcount(self, num_atoms):\n        \"\"\"Benchmark counting of atoms in\n        atomgroup.\n        \"\"\"\n        self.ag.n_atoms\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]",
        "name": "ag_methods.AtomGroupAttrsBench.time_atomcount",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "d31f8341e31a7bc198133f258c72536b54ec904f97ac4f28a767f9970856818a",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupAttrsBench.time_atoms": {
        "code": "class AtomGroupAttrsBench:\n    def time_atoms(self, num_atoms):\n        \"\"\"Benchmark returning of identical\n        atomgroup.\n        \"\"\"\n        self.ag.atoms\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]",
        "name": "ag_methods.AtomGroupAttrsBench.time_atoms",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "6cd2f945901dc324d1dabcb388bc3fe0c3b5977d49056e5d7a7859c40e2c9af8",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupAttrsBench.time_bond": {
        "code": "class AtomGroupAttrsBench:\n    def time_bond(self, num_atoms):\n        \"\"\"Benchmark Bond object creation.\n        Requires ag of size 2.\n        \"\"\"\n        self.ag[:2].bond\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]",
        "name": "ag_methods.AtomGroupAttrsBench.time_bond",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "3507b8355b5b01697e086a646c559412d09fde51fc7139f4524f7cb58aa7ae67",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupAttrsBench.time_dihedral": {
        "code": "class AtomGroupAttrsBench:\n    def time_dihedral(self, num_atoms):\n        \"\"\"Benchmark Dihedral object\n        creation time. Requires ag of\n        size 4.\n        \"\"\"\n        self.ag[:4].dihedral\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]",
        "name": "ag_methods.AtomGroupAttrsBench.time_dihedral",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "5775f1a2f7666febcc47f94b77702bd75a2a7ccd7c9044265c965dbad779a351",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupAttrsBench.time_forces": {
        "code": "class AtomGroupAttrsBench:\n    def time_forces(self, num_atoms):\n        \"\"\"Benchmark atomgroup force\n        calculation.\n        \"\"\"\n        try:\n            self.ag.forces\n        except NoDataError:\n            pass\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]",
        "name": "ag_methods.AtomGroupAttrsBench.time_forces",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "0186fc73e76b8e3f8cb39e7e11f7c6e9837d800b2379b14591432ee9e710d69e",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupAttrsBench.time_improper": {
        "code": "class AtomGroupAttrsBench:\n    def time_improper(self, num_atoms):\n        \"\"\"Benchmark improper dihedral\n        calculation. Requires ag of size\n        4.\n        \"\"\"\n        self.ag[:4].improper\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]",
        "name": "ag_methods.AtomGroupAttrsBench.time_improper",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "d7ba217b21841225ff1df0b473d66794db6b2c92c56bbb3cb04c042fb43e967c",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupAttrsBench.time_indices": {
        "code": "class AtomGroupAttrsBench:\n    def time_indices(self, num_atoms):\n        \"\"\"Benchmark atom index calculation.\n        \"\"\"\n        self.ag.ix\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]",
        "name": "ag_methods.AtomGroupAttrsBench.time_indices",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "8a27cd7f019ca3f35aa37d112e72f6b0311c37dee14a33adff3dffd8b6ee2602",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupAttrsBench.time_positions": {
        "code": "class AtomGroupAttrsBench:\n    def time_positions(self, num_atoms):\n        \"\"\"Benchmark returning the positions\n        of the atoms in the group.\n        \"\"\"\n        self.ag.positions\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]",
        "name": "ag_methods.AtomGroupAttrsBench.time_positions",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "7f538e5ccf7c68b715cb9ba1f0a85764faa5e09216ba83be3b88804f26504dcd",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupAttrsBench.time_residuecount": {
        "code": "class AtomGroupAttrsBench:\n    def time_residuecount(self, num_atoms):\n        \"\"\"Benchmark counting of residues in\n        atomgroup.\n        \"\"\"\n        self.ag.n_residues\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]",
        "name": "ag_methods.AtomGroupAttrsBench.time_residuecount",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "6ba8023af1d40da84022b2eba1e494b20eb80d1257fa5beabc2206f8d380b237",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupAttrsBench.time_residues": {
        "code": "class AtomGroupAttrsBench:\n    def time_residues(self, num_atoms):\n        \"\"\"Benchmark creation of the ResidueGroup\n        from the AtomGroup.\n        \"\"\"\n        self.ag.residues\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]",
        "name": "ag_methods.AtomGroupAttrsBench.time_residues",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "72655f2bf91db254ada1b26646da826894a223384a4691f99b06b291107b938e",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupAttrsBench.time_segmentcount": {
        "code": "class AtomGroupAttrsBench:\n    def time_segmentcount(self, num_atoms):\n        \"\"\"Benchmark counting of segments in\n        atomgroup.\n        \"\"\"\n        self.ag.n_segments\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]",
        "name": "ag_methods.AtomGroupAttrsBench.time_segmentcount",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "ea9ccc59b78a3786c8ed142a014c476162b2d37437c8f93a4b05644dd851aede",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupAttrsBench.time_segments": {
        "code": "class AtomGroupAttrsBench:\n    def time_segments(self, num_atoms):\n        \"\"\"Benchmark determination of sorted\n        SegmentGroup from AtomGroup.\n        \"\"\"\n        self.ag.segments\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]",
        "name": "ag_methods.AtomGroupAttrsBench.time_segments",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "ec21432839b2caac695337844d8b3feff546e74083cc61d846692523160bcf70",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupAttrsBench.time_ts": {
        "code": "class AtomGroupAttrsBench:\n    def time_ts(self, num_atoms):\n        \"\"\"Benchmark returning of a timestep\n        instance from atomgroup.\n        \"\"\"\n        self.ag.ts\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]",
        "name": "ag_methods.AtomGroupAttrsBench.time_ts",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "0aadba3b29a020c1edbc55253049c8f9dc252759321e51f110ca895d99ce52a6",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupAttrsBench.time_unique": {
        "code": "class AtomGroupAttrsBench:\n    def time_unique(self, num_atoms):\n        \"\"\"Benchmark determination of unique\n        elements in atomgroup.\n        \"\"\"\n        self.ag.unique\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]",
        "name": "ag_methods.AtomGroupAttrsBench.time_unique",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "1c2345530d78545ab7011e17420325ec0f2b12a472ade667a7253fd672a06f70",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupAttrsBench.time_velocity": {
        "code": "class AtomGroupAttrsBench:\n    def time_velocity(self, num_atoms):\n        \"\"\"Benchmark atomgroup velocity\n        values return.\n        \"\"\"\n        try:\n            self.ag.velocities\n        except NoDataError:\n            pass\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]",
        "name": "ag_methods.AtomGroupAttrsBench.time_velocity",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "3841e8cfb0518bdc257c0479f3844b8bdf80ee1e2bf7b2245ba4ba95533e2ce8",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_bbox_no_pbc": {
        "code": "class AtomGroupMethodsBench:\n    def time_bbox_no_pbc(self, num_atoms):\n        \"\"\"Benchmark bounding box calculation\n        with pbc inactive.\n        \"\"\"\n        self.ag.bbox(pbc=False)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'H':1.0,\n                         'C':1.0,\n                         'N':1.0,\n                         'O':1.0,\n                         'DUMMY':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "name": "ag_methods.AtomGroupMethodsBench.time_bbox_no_pbc",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f4d3c92e8dc5efa1a09726e3c1dea49453d5625ee6952475869546919575a0ed",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_bbox_pbc": {
        "code": "class AtomGroupMethodsBench:\n    def time_bbox_pbc(self, num_atoms):\n        \"\"\"Benchmark bounding box calculation\n        with pbc active.\n        \"\"\"\n        self.ag.bbox(pbc=True)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'H':1.0,\n                         'C':1.0,\n                         'N':1.0,\n                         'O':1.0,\n                         'DUMMY':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "name": "ag_methods.AtomGroupMethodsBench.time_bbox_pbc",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "02deed74348541e19fd7811f9aa232bd53410903de3a1432d7cc090a3184198e",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_bsphere_no_pbc": {
        "code": "class AtomGroupMethodsBench:\n    def time_bsphere_no_pbc(self, num_atoms):\n        \"\"\"Benchmark bounding sphere calculation\n        with pbc inactive.\n        \"\"\"\n        self.ag.bsphere(pbc=False)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'H':1.0,\n                         'C':1.0,\n                         'N':1.0,\n                         'O':1.0,\n                         'DUMMY':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "name": "ag_methods.AtomGroupMethodsBench.time_bsphere_no_pbc",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "7f229e23767623d3052357b0d2e36620742990cbec01fa9df982997a64d0b558",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_bsphere_pbc": {
        "code": "class AtomGroupMethodsBench:\n    def time_bsphere_pbc(self, num_atoms):\n        \"\"\"Benchmark bounding sphere calculation\n        with pbc active.\n        \"\"\"\n        self.ag.bsphere(pbc=True)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'H':1.0,\n                         'C':1.0,\n                         'N':1.0,\n                         'O':1.0,\n                         'DUMMY':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "name": "ag_methods.AtomGroupMethodsBench.time_bsphere_pbc",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "669f068c60e5023f28ea98225386244efdd0907ea6895c590088cfd170bef050",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_center_no_pbc": {
        "code": "class AtomGroupMethodsBench:\n    def time_center_no_pbc(self, num_atoms):\n        \"\"\"Benchmark center calculation with\n        pbc inactive.\n        \"\"\"\n        self.ag.center(weights=self.weights,\n                       pbc=False)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'H':1.0,\n                         'C':1.0,\n                         'N':1.0,\n                         'O':1.0,\n                         'DUMMY':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "name": "ag_methods.AtomGroupMethodsBench.time_center_no_pbc",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "5499bbde1d376804c4c410b7cac45ebc709dc4065d374891ccaca4c67b497d8d",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_center_pbc": {
        "code": "class AtomGroupMethodsBench:\n    def time_center_pbc(self, num_atoms):\n        \"\"\"Benchmark center calculation with\n        pbc active.\n        \"\"\"\n        self.ag.center(weights=self.weights,\n                       pbc=True)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'H':1.0,\n                         'C':1.0,\n                         'N':1.0,\n                         'O':1.0,\n                         'DUMMY':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "name": "ag_methods.AtomGroupMethodsBench.time_center_pbc",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "9e281b5399aef60e0a823b2a228dee94c0e31bd95d8806c1e15b861cf23d83b6",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_centroid_no_pbc": {
        "code": "class AtomGroupMethodsBench:\n    def time_centroid_no_pbc(self, num_atoms):\n        \"\"\"Benchmark centroid calculation with\n        pbc inactive.\n        \"\"\"\n        self.ag.centroid(pbc=False)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'H':1.0,\n                         'C':1.0,\n                         'N':1.0,\n                         'O':1.0,\n                         'DUMMY':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "name": "ag_methods.AtomGroupMethodsBench.time_centroid_no_pbc",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "56366be992afa8468328495085d4bd7f270fe821af6b4412e097e071a5841aba",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_centroid_pbc": {
        "code": "class AtomGroupMethodsBench:\n    def time_centroid_pbc(self, num_atoms):\n        \"\"\"Benchmark centroid calculation with\n        pbc active.\n        \"\"\"\n        self.ag.centroid(pbc=True)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'H':1.0,\n                         'C':1.0,\n                         'N':1.0,\n                         'O':1.0,\n                         'DUMMY':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "name": "ag_methods.AtomGroupMethodsBench.time_centroid_pbc",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "7ce43af0540e7c4b35689a263dfc228d0a4a2d2d92727d2d44b1e397c32a8726",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_concatenate": {
        "code": "class AtomGroupMethodsBench:\n    def time_concatenate(self, num_atoms):\n        \"\"\"Benchmark atomgroup concatenation.\n        \"\"\"\n        self.ag.concatenate(self.ag)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'H':1.0,\n                         'C':1.0,\n                         'N':1.0,\n                         'O':1.0,\n                         'DUMMY':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "name": "ag_methods.AtomGroupMethodsBench.time_concatenate",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "d5249c87dfce2c91bde201106b2e4198849051c93364564de86ce872159c1428",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_difference": {
        "code": "class AtomGroupMethodsBench:\n    def time_difference(self, num_atoms):\n        \"\"\"Benchmark atomgroup difference\n        operation.\n        \"\"\"\n        self.ag.difference(self.ag)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'H':1.0,\n                         'C':1.0,\n                         'N':1.0,\n                         'O':1.0,\n                         'DUMMY':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "name": "ag_methods.AtomGroupMethodsBench.time_difference",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "56ce3f2f2c4257dee720e7b07315ce2595afc66137f7324b405ebfb060e65dd3",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_groupby": {
        "code": "class AtomGroupMethodsBench:\n    def time_groupby(self, num_atoms):\n        \"\"\"Benchmark atomgroup groupby\n        operation.\n        \"\"\"\n        self.ag.groupby('resnames')\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'H':1.0,\n                         'C':1.0,\n                         'N':1.0,\n                         'O':1.0,\n                         'DUMMY':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "name": "ag_methods.AtomGroupMethodsBench.time_groupby",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "e42dfd364b2726e568511c4eae084feead8bd62e3ac3d2046ca6c0ae2a061363",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_guess_bonds": {
        "code": "class AtomGroupMethodsBench:\n    def time_guess_bonds(self, num_atoms):\n        \"\"\"Benchmark atomgroup bond guessing\n        with artificially-seeded vdw values.\n        \"\"\"\n        self.ag.guess_bonds(self.vdwradii)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'H':1.0,\n                         'C':1.0,\n                         'N':1.0,\n                         'O':1.0,\n                         'DUMMY':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "name": "ag_methods.AtomGroupMethodsBench.time_guess_bonds",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "b22111561b487e88b079412e82b48de4d70d39b0c868ec64305cebdcdf3ecd0b",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_intersection": {
        "code": "class AtomGroupMethodsBench:\n    def time_intersection(self, num_atoms):\n        \"\"\"Benchmark ag intersection.\n        \"\"\"\n        self.ag.intersection(self.ag)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'H':1.0,\n                         'C':1.0,\n                         'N':1.0,\n                         'O':1.0,\n                         'DUMMY':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "name": "ag_methods.AtomGroupMethodsBench.time_intersection",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "af81d67c8ba6789db6632156d5ee37d16c1d7145bc51d97faf62f5a44e71a216",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_is_strict_subset": {
        "code": "class AtomGroupMethodsBench:\n    def time_is_strict_subset(self, num_atoms):\n        \"\"\"Benchmark ag strict subset operation.\n        \"\"\"\n        self.ag.is_strict_subset(self.ag)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'H':1.0,\n                         'C':1.0,\n                         'N':1.0,\n                         'O':1.0,\n                         'DUMMY':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "name": "ag_methods.AtomGroupMethodsBench.time_is_strict_subset",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "4dff2b0102568196662f408ec7682e479b1f28f3c0811e1d09928f67803ff1fd",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_is_strict_superset": {
        "code": "class AtomGroupMethodsBench:\n    def time_is_strict_superset(self, num_atoms):\n        \"\"\"Benchmark ag strict superset operation.\n        \"\"\"\n        self.ag.is_strict_superset(self.ag)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'H':1.0,\n                         'C':1.0,\n                         'N':1.0,\n                         'O':1.0,\n                         'DUMMY':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "name": "ag_methods.AtomGroupMethodsBench.time_is_strict_superset",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "2c81f4e274971df7fb627c5c8e82a821572d65175a56f86824b9a5d644170653",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_isdisjoint": {
        "code": "class AtomGroupMethodsBench:\n    def time_isdisjoint(self, num_atoms):\n        \"\"\"Benchmark disjoint operation between\n        atomgroups.\n        \"\"\"\n        self.ag.isdisjoint(self.ag)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'H':1.0,\n                         'C':1.0,\n                         'N':1.0,\n                         'O':1.0,\n                         'DUMMY':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "name": "ag_methods.AtomGroupMethodsBench.time_isdisjoint",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "9573a798d7d80b64066ae7114626b83b763312b43c4435eac392b8c0d3fb8a08",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_issubset": {
        "code": "class AtomGroupMethodsBench:\n    def time_issubset(self, num_atoms):\n        \"\"\"Benchmark subset operation between\n        atomgroups.\n        \"\"\"\n        self.ag.issubset(self.ag)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'H':1.0,\n                         'C':1.0,\n                         'N':1.0,\n                         'O':1.0,\n                         'DUMMY':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "name": "ag_methods.AtomGroupMethodsBench.time_issubset",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f6bd03304591ed1af9f0654198f07148f408505a8ba8d1ec24c4613d5980686b",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_issuperset": {
        "code": "class AtomGroupMethodsBench:\n    def time_issuperset(self, num_atoms):\n        \"\"\"Benchmark superset operation between\n        atomgroups.\n        \"\"\"\n        self.ag.issuperset(self.ag)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'H':1.0,\n                         'C':1.0,\n                         'N':1.0,\n                         'O':1.0,\n                         'DUMMY':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "name": "ag_methods.AtomGroupMethodsBench.time_issuperset",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "da0c4343c5544f68e3ee19e45eb427df5f51ad6fdf3d3a1380d864a310e832f1",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_pack_into_box": {
        "code": "class AtomGroupMethodsBench:\n    def time_pack_into_box(self, num_atoms):\n        \"\"\"Benchmark shifting atoms of ag\n        into primary unit cell, using\n        default parameters.\n        \"\"\"\n        self.ag.pack_into_box()\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'H':1.0,\n                         'C':1.0,\n                         'N':1.0,\n                         'O':1.0,\n                         'DUMMY':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "name": "ag_methods.AtomGroupMethodsBench.time_pack_into_box",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "54f8934b8fe61ba797a7909743b108e39de31f183b1e1ae485cf0f6ce32462c7",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_rotate": {
        "code": "class AtomGroupMethodsBench:\n    def time_rotate(self, num_atoms):\n        \"\"\"Benchmark simple rotation operation\n        on atomgroup.\n        \"\"\"\n        self.ag.rotate(self.rot_matrix)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'H':1.0,\n                         'C':1.0,\n                         'N':1.0,\n                         'O':1.0,\n                         'DUMMY':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "name": "ag_methods.AtomGroupMethodsBench.time_rotate",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "6e1749c80e708a81dc9b1c9e930f935e6c602721ffd2c8aaef3124f78895e3fc",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_rotateby": {
        "code": "class AtomGroupMethodsBench:\n    def time_rotateby(self, num_atoms):\n        \"\"\"Benchmark rotation by an angle\n        of the ag coordinates.\n        \"\"\"\n        self.ag.rotateby(angle=45,\n                         axis=[1,0,0])\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'H':1.0,\n                         'C':1.0,\n                         'N':1.0,\n                         'O':1.0,\n                         'DUMMY':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "name": "ag_methods.AtomGroupMethodsBench.time_rotateby",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "3a363526876a2804ba8aa888ffe51737d852a4f374b4afcea48089e448dd31cb",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_split": {
        "code": "class AtomGroupMethodsBench:\n    def time_split(self, num_atoms):\n        \"\"\"Benchmark ag splitting into\n        multiple ags based on a simple\n        criterion.\n        \"\"\"\n        self.ag.split('residue')\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'H':1.0,\n                         'C':1.0,\n                         'N':1.0,\n                         'O':1.0,\n                         'DUMMY':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "name": "ag_methods.AtomGroupMethodsBench.time_split",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "416f626f3c7231a69b7aeff75fba459fe50c0154712be099617e3bbb6e5916d4",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_subtract": {
        "code": "class AtomGroupMethodsBench:\n    def time_subtract(self, num_atoms):\n        \"\"\"Benchmark ag subtraction.\n        \"\"\"\n        self.ag.subtract(self.ag)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'H':1.0,\n                         'C':1.0,\n                         'N':1.0,\n                         'O':1.0,\n                         'DUMMY':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "name": "ag_methods.AtomGroupMethodsBench.time_subtract",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "a850d565fa6aecc39128e9d35a85496508288f8b8989d9fdb21f77796d838786",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_symmetric_difference": {
        "code": "class AtomGroupMethodsBench:\n    def time_symmetric_difference(self, num_atoms):\n        \"\"\"Benchmark ag symmetric difference\n        operation.\n        \"\"\"\n        self.ag.symmetric_difference(self.ag)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'H':1.0,\n                         'C':1.0,\n                         'N':1.0,\n                         'O':1.0,\n                         'DUMMY':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "name": "ag_methods.AtomGroupMethodsBench.time_symmetric_difference",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "0f5ae06c5f76555fb6a63e41f85fd32373e10d49a309803a4b06be75e05ec0a9",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_transform": {
        "code": "class AtomGroupMethodsBench:\n    def time_transform(self, num_atoms):\n        \"\"\"Benchmark application of transformation\n        matrix to atomgroup.\n        \"\"\"\n        self.ag.transform(self.trans)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'H':1.0,\n                         'C':1.0,\n                         'N':1.0,\n                         'O':1.0,\n                         'DUMMY':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "name": "ag_methods.AtomGroupMethodsBench.time_transform",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "6dc5031197d6b02edba0f8d4bd19cec798be5c5b740547575f7cade39a38b391",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_translate": {
        "code": "class AtomGroupMethodsBench:\n    def time_translate(self, num_atoms):\n        \"\"\"Benchmark the application of a\n        translation vector to the ag\n        coordinates.\n        \"\"\"\n        self.ag.translate([0,0.5,1])\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'H':1.0,\n                         'C':1.0,\n                         'N':1.0,\n                         'O':1.0,\n                         'DUMMY':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "name": "ag_methods.AtomGroupMethodsBench.time_translate",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "97a8195e6e8cd22f3b5cfa3a9f162d518b497d64e2cd734e91212b74e9620d3a",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_union": {
        "code": "class AtomGroupMethodsBench:\n    def time_union(self, num_atoms):\n        \"\"\"Benchmark union operation\n        on atomgroups.\n        \"\"\"\n        self.ag.union(self.ag)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'H':1.0,\n                         'C':1.0,\n                         'N':1.0,\n                         'O':1.0,\n                         'DUMMY':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "name": "ag_methods.AtomGroupMethodsBench.time_union",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "3e19a73408a52eca4f12d1df1f083093bf51de80adc8a78f3448451658ae113b",
        "warmup_time": -1
    },
    "ag_methods.AtomGroupMethodsBench.time_wrap": {
        "code": "class AtomGroupMethodsBench:\n    def time_wrap(self, num_atoms):\n        \"\"\"Benchmark wrap() operation on\n        atomgroup with default params.\n        \"\"\"\n        self.ag.wrap()\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.weights = np.ones(num_atoms)\n        self.vdwradii = {'H':1.0,\n                         'C':1.0,\n                         'N':1.0,\n                         'O':1.0,\n                         'DUMMY':1.0}\n        self.rot_matrix = np.ones((3,3))\n        self.trans = np.ones((4,4))",
        "name": "ag_methods.AtomGroupMethodsBench.time_wrap",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "e17b327697d267cf044412cc544be3b2e309edad29b10d0ab5af64a7b847d269",
        "warmup_time": -1
    },
    "analysis.distances.DistancesBench.time_between": {
        "code": "class DistancesBench:\n    def time_between(self, num_atoms):\n        \"\"\"Benchmark determination of subgroup\n        of atomgroup that is within a specific\n        distance of two other atomgroups.\n        \"\"\"\n        distances.between(group=self.ag3,\n                          A=self.ag1,\n                          B=self.ag2,\n                          distance=15.0)\n\n    def setup(self, num_atoms):\n        np.random.seed(17809)\n        self.coords_1 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(9008716)\n        self.coords_2 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        self.allocated_array_2D = np.empty((num_atoms, num_atoms),\n                                            dtype=np.float64)\n        self.array_shape_1D = int(num_atoms * (num_atoms - 1) / 2.)\n        self.allocated_array_1D = np.empty(self.array_shape_1D,\n                                           dtype=np.float64)\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag1 = self.u.atoms[:num_atoms]\n        self.ag2 = self.u.atoms[num_atoms: 2 * num_atoms]\n        self.ag3 = self.u.atoms[-num_atoms:]",
        "name": "analysis.distances.DistancesBench.time_between",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "eb885148f4da07fe9037d6f5c72f6730a0389638e247a928686fcbd8a19214da",
        "warmup_time": -1
    },
    "analysis.distances.DistancesBench.time_contact_matrix": {
        "code": "class DistancesBench:\n    def time_contact_matrix(self, num_atoms):\n        \"\"\"Benchmark calculation of contacts within\n        a single numpy array using the default arguments\n        to contact_matrix.\n        \"\"\"\n        distances.contact_matrix(coord=self.coords_1,\n                                 cutoff=15.0,\n                                 returntype='numpy',\n                                 box=None)\n\n    def setup(self, num_atoms):\n        np.random.seed(17809)\n        self.coords_1 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(9008716)\n        self.coords_2 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        self.allocated_array_2D = np.empty((num_atoms, num_atoms),\n                                            dtype=np.float64)\n        self.array_shape_1D = int(num_atoms * (num_atoms - 1) / 2.)\n        self.allocated_array_1D = np.empty(self.array_shape_1D,\n                                           dtype=np.float64)\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag1 = self.u.atoms[:num_atoms]\n        self.ag2 = self.u.atoms[num_atoms: 2 * num_atoms]\n        self.ag3 = self.u.atoms[-num_atoms:]",
        "name": "analysis.distances.DistancesBench.time_contact_matrix",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "6e4d4f50f6cb85908c188ebfd6de7c40fa3d3df6afef146e01518c709445ccd0",
        "warmup_time": -1
    },
    "analysis.distances.DistancesBench.time_contact_matrix_sparse": {
        "code": "class DistancesBench:\n    def time_contact_matrix_sparse(self, num_atoms):\n        \"\"\"Benchmark calculation of contacts within\n        a single numpy array using the slower reduced\n        memory implementation of contact_matrix intended\n        for larger systems.\n        \"\"\"\n        distances.contact_matrix(coord=self.coords_1,\n                                 cutoff=15.0,\n                                 returntype='sparse',\n                                 box=None)\n\n    def setup(self, num_atoms):\n        np.random.seed(17809)\n        self.coords_1 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(9008716)\n        self.coords_2 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        self.allocated_array_2D = np.empty((num_atoms, num_atoms),\n                                            dtype=np.float64)\n        self.array_shape_1D = int(num_atoms * (num_atoms - 1) / 2.)\n        self.allocated_array_1D = np.empty(self.array_shape_1D,\n                                           dtype=np.float64)\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag1 = self.u.atoms[:num_atoms]\n        self.ag2 = self.u.atoms[num_atoms: 2 * num_atoms]\n        self.ag3 = self.u.atoms[-num_atoms:]",
        "name": "analysis.distances.DistancesBench.time_contact_matrix_sparse",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "4e6d14cd551f572db95de56c5260a5490105139c9c439440473639dcac59bf56",
        "warmup_time": -1
    },
    "analysis.distances.DistancesBench.time_dist": {
        "code": "class DistancesBench:\n    def time_dist(self, num_atoms):\n        \"\"\"Benchmark calculation of distances between\n        atoms in two atomgroups with no offsets\n        to resids.\n        \"\"\"\n        distances.dist(A=self.ag1,\n                       B=self.ag2,\n                       offset=0)\n\n    def setup(self, num_atoms):\n        np.random.seed(17809)\n        self.coords_1 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(9008716)\n        self.coords_2 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        self.allocated_array_2D = np.empty((num_atoms, num_atoms),\n                                            dtype=np.float64)\n        self.array_shape_1D = int(num_atoms * (num_atoms - 1) / 2.)\n        self.allocated_array_1D = np.empty(self.array_shape_1D,\n                                           dtype=np.float64)\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag1 = self.u.atoms[:num_atoms]\n        self.ag2 = self.u.atoms[num_atoms: 2 * num_atoms]\n        self.ag3 = self.u.atoms[-num_atoms:]",
        "name": "analysis.distances.DistancesBench.time_dist",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "1e316d102d15001127985bbeadcda61a289f6b0c49edf8beb7c8ac292fc70883",
        "warmup_time": -1
    },
    "analysis.distances.DistancesBench.time_dist_offsets": {
        "code": "class DistancesBench:\n    def time_dist_offsets(self, num_atoms):\n        \"\"\"Benchmark calculation of distances between\n        atoms in two atomgroups with offsets\n        to resids.\n        \"\"\"\n        distances.dist(A=self.ag1,\n                       B=self.ag2,\n                       offset=20)\n\n    def setup(self, num_atoms):\n        np.random.seed(17809)\n        self.coords_1 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(9008716)\n        self.coords_2 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        self.allocated_array_2D = np.empty((num_atoms, num_atoms),\n                                            dtype=np.float64)\n        self.array_shape_1D = int(num_atoms * (num_atoms - 1) / 2.)\n        self.allocated_array_1D = np.empty(self.array_shape_1D,\n                                           dtype=np.float64)\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag1 = self.u.atoms[:num_atoms]\n        self.ag2 = self.u.atoms[num_atoms: 2 * num_atoms]\n        self.ag3 = self.u.atoms[-num_atoms:]",
        "name": "analysis.distances.DistancesBench.time_dist_offsets",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "0766fec1b0ea981f2f91bc7b592c2c7faa4c27e5821747d0e3f7f27ad30f22e6",
        "warmup_time": -1
    },
    "analysis.distances.DistancesBench.time_distance_array": {
        "code": "class DistancesBench:\n    def time_distance_array(self, num_atoms):\n        \"\"\"Benchmark calculation of all distances\n        between two numpy arrays of coordinates,\n        using default arguments to distance_array.\n        \"\"\"\n        distances.distance_array(reference=self.coords_1,\n                                 configuration=self.coords_2,\n                                 box=None,\n                                 result=None,\n                                 backend='serial')\n\n    def setup(self, num_atoms):\n        np.random.seed(17809)\n        self.coords_1 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(9008716)\n        self.coords_2 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        self.allocated_array_2D = np.empty((num_atoms, num_atoms),\n                                            dtype=np.float64)\n        self.array_shape_1D = int(num_atoms * (num_atoms - 1) / 2.)\n        self.allocated_array_1D = np.empty(self.array_shape_1D,\n                                           dtype=np.float64)\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag1 = self.u.atoms[:num_atoms]\n        self.ag2 = self.u.atoms[num_atoms: 2 * num_atoms]\n        self.ag3 = self.u.atoms[-num_atoms:]",
        "name": "analysis.distances.DistancesBench.time_distance_array",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "6b47aceaee90f91587947029fdaef396adac215eb2ef3057c85f9e410a3e5fa7",
        "warmup_time": -1
    },
    "analysis.distances.DistancesBench.time_distance_array_pre_allocated": {
        "code": "class DistancesBench:\n    def time_distance_array_pre_allocated(self, num_atoms):\n        \"\"\"Benchmark calculation of all distances\n        between two numpy arrays of coordinates,\n        using distance_array with a preallocated\n        result array.\n        \"\"\"\n        distances.distance_array(reference=self.coords_1,\n                                 configuration=self.coords_2,\n                                 box=None,\n                                 result=self.allocated_array_2D,\n                                 backend='serial')\n\n    def setup(self, num_atoms):\n        np.random.seed(17809)\n        self.coords_1 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(9008716)\n        self.coords_2 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        self.allocated_array_2D = np.empty((num_atoms, num_atoms),\n                                            dtype=np.float64)\n        self.array_shape_1D = int(num_atoms * (num_atoms - 1) / 2.)\n        self.allocated_array_1D = np.empty(self.array_shape_1D,\n                                           dtype=np.float64)\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag1 = self.u.atoms[:num_atoms]\n        self.ag2 = self.u.atoms[num_atoms: 2 * num_atoms]\n        self.ag3 = self.u.atoms[-num_atoms:]",
        "name": "analysis.distances.DistancesBench.time_distance_array_pre_allocated",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "3988cf77ee5eccd5483b603b31c7c25b63f73aa81b757689f2c8bdd9f062ae82",
        "warmup_time": -1
    },
    "analysis.distances.DistancesBench.time_self_distance_array": {
        "code": "class DistancesBench:\n    def time_self_distance_array(self, num_atoms):\n        \"\"\"Benchmark calculation of all distances\n        within a single numpy array of coordinates\n        using default parameters to self_distance_array.\n        \"\"\"\n        distances.self_distance_array(reference=self.coords_1,\n                                      box=None,\n                                      result=None,\n                                      backend='serial')\n\n    def setup(self, num_atoms):\n        np.random.seed(17809)\n        self.coords_1 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(9008716)\n        self.coords_2 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        self.allocated_array_2D = np.empty((num_atoms, num_atoms),\n                                            dtype=np.float64)\n        self.array_shape_1D = int(num_atoms * (num_atoms - 1) / 2.)\n        self.allocated_array_1D = np.empty(self.array_shape_1D,\n                                           dtype=np.float64)\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag1 = self.u.atoms[:num_atoms]\n        self.ag2 = self.u.atoms[num_atoms: 2 * num_atoms]\n        self.ag3 = self.u.atoms[-num_atoms:]",
        "name": "analysis.distances.DistancesBench.time_self_distance_array",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "c6dbef3ff4b6c03b07405740d628a4dbd6c5e558b910137a157196ed94020286",
        "warmup_time": -1
    },
    "analysis.distances.DistancesBench.time_self_distance_array_pre_allocated": {
        "code": "class DistancesBench:\n    def time_self_distance_array_pre_allocated(self, num_atoms):\n        \"\"\"Benchmark calculation of all distances\n        within a single numpy array of coordinates\n        using self_distance_array with preallocated\n        result array.\n        \"\"\"\n        distances.self_distance_array(reference=self.coords_1,\n                                      box=None,\n                                      result=self.allocated_array_1D,\n                                      backend='serial')\n\n    def setup(self, num_atoms):\n        np.random.seed(17809)\n        self.coords_1 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        np.random.seed(9008716)\n        self.coords_2 = np.random.random_sample((num_atoms, 3)).astype(np.float32)\n        self.allocated_array_2D = np.empty((num_atoms, num_atoms),\n                                            dtype=np.float64)\n        self.array_shape_1D = int(num_atoms * (num_atoms - 1) / 2.)\n        self.allocated_array_1D = np.empty(self.array_shape_1D,\n                                           dtype=np.float64)\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag1 = self.u.atoms[:num_atoms]\n        self.ag2 = self.u.atoms[num_atoms: 2 * num_atoms]\n        self.ag3 = self.u.atoms[-num_atoms:]",
        "name": "analysis.distances.DistancesBench.time_self_distance_array_pre_allocated",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "252de8a508db72096fb84cad267be871be5133ab5e2a35ea5b1dbf4d610c3f4e",
        "warmup_time": -1
    },
    "analysis.leaflet.LeafletBench.time_leafletfinder": {
        "code": "class LeafletBench:\n    def time_leafletfinder(self, cutoff, sparse, pbc):\n        \"\"\"Benchmark LeafletFinder for test lipid\n        membrane system.\n        \"\"\"\n        leaflet.LeafletFinder(universe=self.u,\n                              selectionstring=self.headgroup_sel,\n                              cutoff=cutoff,\n                              pbc=pbc,\n                              sparse=sparse)\n\n    def setup(self, cutoff, sparse, pbc):\n        self.u = MDAnalysis.Universe(Martini_membrane_gro)\n        self.headgroup_sel = 'name PO4'",
        "name": "analysis.leaflet.LeafletBench.time_leafletfinder",
        "number": 0,
        "param_names": [
            "cutoff",
            "sparse",
            "pbc"
        ],
        "params": [
            [
                "7.0",
                "15.0",
                "23.0"
            ],
            [
                "None",
                "True",
                "False"
            ],
            [
                "True",
                "False"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "7cc51105a1891b5d2b1fef3302766e183867f8867aa8b79557daa1cc472a6f4e",
        "warmup_time": -1
    },
    "analysis.leaflet.LeafletOptimizeBench.time_optimize_cutoff": {
        "code": "class LeafletOptimizeBench:\n    def time_optimize_cutoff(self, sparse, pbc):\n        \"\"\"Benchmark optimize_cutoff for test lipid\n        membrane system using default network distance\n        range.\n        \"\"\"\n        leaflet.optimize_cutoff(universe=self.u,\n                                selection=self.headgroup_sel,\n                                pbc=pbc,\n                                sparse=sparse)\n\n    def setup(self, sparse, pbc):\n        self.u = MDAnalysis.Universe(Martini_membrane_gro)\n        self.headgroup_sel = 'name PO4'",
        "name": "analysis.leaflet.LeafletOptimizeBench.time_optimize_cutoff",
        "number": 0,
        "param_names": [
            "sparse",
            "pbc"
        ],
        "params": [
            [
                "None",
                "True",
                "False"
            ],
            [
                "True",
                "False"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "c2594da2d6b564ca7b231a1e6c28e4d7b1c330259c6b64a9ede16bd1953450b7",
        "warmup_time": -1
    },
    "analysis.psa.PSA_get_coord_axesBench.time_get_coord_axes": {
        "code": "class PSA_get_coord_axesBench:\n    def time_get_coord_axes(self, time_steps, n_atoms):\n        \"\"\"Benchmark get_coord_axes in psa module\n        \"\"\"\n        psa.get_coord_axes(path=self.path)\n\n    def setup(self, time_steps, n_atoms):\n        np.random.seed(170089)\n        # only using condensed path input\n        # data structure for now\n        self.path = np.random.rand(time_steps,\n                                   n_atoms * 3)",
        "name": "analysis.psa.PSA_get_coord_axesBench.time_get_coord_axes",
        "number": 0,
        "param_names": [
            "time_steps",
            "n_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000"
            ],
            [
                "5",
                "25",
                "50"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "86cb5086b8445a130e30b1506114ef9279166f177f3b89ad2641253d58117f93",
        "warmup_time": -1
    },
    "analysis.psa.PSA_get_msd_matrixBench.time_get_msd_matrix": {
        "code": "class PSA_get_msd_matrixBench:\n    def time_get_msd_matrix(self, time_steps, n_atoms):\n        \"\"\"Benchmark for get_msd_matrix in psa module\n        \"\"\"\n        # only default argument for axis is benchmarked\n        psa.get_msd_matrix(P=self.P,\n                           Q=self.Q,\n                           axis=None)\n\n    def setup(self, time_steps, n_atoms):\n        np.random.seed(170089)\n        self.P = np.random.rand(time_steps,\n                                n_atoms,\n                                3)\n        np.random.seed(971132)\n        self.Q = np.random.rand(time_steps,\n                                n_atoms,\n                                3)",
        "name": "analysis.psa.PSA_get_msd_matrixBench.time_get_msd_matrix",
        "number": 0,
        "param_names": [
            "time_steps",
            "n_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000"
            ],
            [
                "5",
                "25",
                "50"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "9dcdda75f655ab20762a5a9c171d804a3f908f3b76043f3fb66e1c5e471aa2c0",
        "warmup_time": -1
    },
    "analysis.psa.PSA_get_path_metric_funcBench.time_get_path_metric_func": {
        "code": "class PSA_get_path_metric_funcBench:\n    def time_get_path_metric_func(self, path_metric):\n        \"\"\"Benchmark for get_path_metric_func in psa\n        module\n        \"\"\"\n        psa.get_path_metric_func(name=path_metric)",
        "name": "analysis.psa.PSA_get_path_metric_funcBench.time_get_path_metric_func",
        "number": 0,
        "param_names": [
            "path_metric"
        ],
        "params": [
            [
                "'hausdorff'",
                "'weighted_average_hausdorff'",
                "'average_hausdorff'",
                "'hausdorff_neighbors'",
                "'discrete_frechet'"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "fc71d48ec5e111b5f38e7d741ab5f63fc3c8615325be6916878225ada0d3e828",
        "warmup_time": -1
    },
    "analysis.psa.PSA_metricBench.time_discrete_frechet": {
        "code": "class PSA_metricBench:\n    def time_discrete_frechet(self, time_steps, n_atoms):\n        \"\"\"Benchmark for discrete_frechet() in psa module.\n        \"\"\"\n        psa.discrete_frechet(P=self.P,\n                             Q=self.Q)\n\n    def setup(self, time_steps, n_atoms):\n        np.random.seed(170089)\n        self.P = np.random.rand(time_steps,\n                                n_atoms,\n                                3)\n        np.random.seed(971132)\n        self.Q = np.random.rand(time_steps,\n                                n_atoms,\n                                3)",
        "name": "analysis.psa.PSA_metricBench.time_discrete_frechet",
        "number": 0,
        "param_names": [
            "time_steps",
            "n_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "200"
            ],
            [
                "5",
                "25",
                "50"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "3bb3d861752ef9ed6f77ac94cad9ed2e42c56d8df988a838892b313d1104b7cb",
        "warmup_time": -1
    },
    "analysis.psa.PSA_metricBench.time_hausdorff": {
        "code": "class PSA_metricBench:\n    def time_hausdorff(self, time_steps, n_atoms):\n        \"\"\"Benchmark for hausdorff() in psa module.\n        \"\"\"\n        psa.hausdorff(P=self.P,\n                      Q=self.Q)\n\n    def setup(self, time_steps, n_atoms):\n        np.random.seed(170089)\n        self.P = np.random.rand(time_steps,\n                                n_atoms,\n                                3)\n        np.random.seed(971132)\n        self.Q = np.random.rand(time_steps,\n                                n_atoms,\n                                3)",
        "name": "analysis.psa.PSA_metricBench.time_hausdorff",
        "number": 0,
        "param_names": [
            "time_steps",
            "n_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "200"
            ],
            [
                "5",
                "25",
                "50"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "e0c90539a3b87665619c0c5923a412b1457f5cf08564b891b2ea25345fc720fc",
        "warmup_time": -1
    },
    "analysis.psa.PSA_metricBench.time_hausdorff_avg": {
        "code": "class PSA_metricBench:\n    def time_hausdorff_avg(self, time_steps, n_atoms):\n        \"\"\"Benchmark for hausdorff_avg() in psa module.\n        \"\"\"\n        psa.hausdorff_avg(P=self.P,\n                          Q=self.Q)\n\n    def setup(self, time_steps, n_atoms):\n        np.random.seed(170089)\n        self.P = np.random.rand(time_steps,\n                                n_atoms,\n                                3)\n        np.random.seed(971132)\n        self.Q = np.random.rand(time_steps,\n                                n_atoms,\n                                3)",
        "name": "analysis.psa.PSA_metricBench.time_hausdorff_avg",
        "number": 0,
        "param_names": [
            "time_steps",
            "n_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "200"
            ],
            [
                "5",
                "25",
                "50"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "bda335edfdd48be1e40d51ba67bd57127dc22570ed81c79b25c9c34e98073cad",
        "warmup_time": -1
    },
    "analysis.psa.PSA_metricBench.time_hausdorff_neighbors": {
        "code": "class PSA_metricBench:\n    def time_hausdorff_neighbors(self, time_steps, n_atoms):\n        \"\"\"Benchmark for hausdorff_neighbors() in psa module.\n        \"\"\"\n        psa.hausdorff_neighbors(P=self.P,\n                                Q=self.Q)\n\n    def setup(self, time_steps, n_atoms):\n        np.random.seed(170089)\n        self.P = np.random.rand(time_steps,\n                                n_atoms,\n                                3)\n        np.random.seed(971132)\n        self.Q = np.random.rand(time_steps,\n                                n_atoms,\n                                3)",
        "name": "analysis.psa.PSA_metricBench.time_hausdorff_neighbors",
        "number": 0,
        "param_names": [
            "time_steps",
            "n_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "200"
            ],
            [
                "5",
                "25",
                "50"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "77321a9a92915cf788b65037e075327c72374c4f6dd8a105749c502756260a7a",
        "warmup_time": -1
    },
    "analysis.psa.PSA_metricBench.time_hausdorff_wavg": {
        "code": "class PSA_metricBench:\n    def time_hausdorff_wavg(self, time_steps, n_atoms):\n        \"\"\"Benchmark for hausdorff_wavg() in psa module.\n        \"\"\"\n        psa.hausdorff_wavg(P=self.P,\n                           Q=self.Q)\n\n    def setup(self, time_steps, n_atoms):\n        np.random.seed(170089)\n        self.P = np.random.rand(time_steps,\n                                n_atoms,\n                                3)\n        np.random.seed(971132)\n        self.Q = np.random.rand(time_steps,\n                                n_atoms,\n                                3)",
        "name": "analysis.psa.PSA_metricBench.time_hausdorff_wavg",
        "number": 0,
        "param_names": [
            "time_steps",
            "n_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "200"
            ],
            [
                "5",
                "25",
                "50"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "162c1711b4953d5045859022df8b1477ad41b166cf80dc31e0b961c87761ed81",
        "warmup_time": -1
    },
    "analysis.psa.PSA_sqnormBench.time_sqnorm": {
        "code": "class PSA_sqnormBench:\n    def time_sqnorm(self, num_cols, num_rows, axis):\n        \"\"\"Benchmark sqnorm in psa module\n        \"\"\"\n        psa.sqnorm(v=self.v, axis=axis)\n\n    def setup(self, num_cols, num_rows, axis):\n        np.random.seed(170089)\n        self.v = np.random.rand(num_rows, num_cols)",
        "name": "analysis.psa.PSA_sqnormBench.time_sqnorm",
        "number": 0,
        "param_names": [
            "num_cols",
            "num_rows",
            "axis"
        ],
        "params": [
            [
                "2",
                "3",
                "4"
            ],
            [
                "100",
                "1000",
                "10000"
            ],
            [
                "None",
                "0",
                "1",
                "-1"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "5360f9d9650b651e056f22f98fd02bda2307b2f2eabb3fbe7c1c4b0dffe5f70b",
        "warmup_time": -1
    },
    "analysis.rdf.SimpleRdfBench.time_interrdf": {
        "code": "class SimpleRdfBench:\n    def time_interrdf(self, nbins, range_val):\n        \"\"\"Benchmark a full trajectory parse\n        by MDAnalysis.analysis.rdf.InterRDF\n        \"\"\"\n        self.rdf.run()\n\n    def setup(self, nbins, range_val, natoms):\n    \n        self.sel_str = 'name OW'\n    \n        self.u = MDAnalysis.Universe(TPR, XTC)\n    \n        try:\n            self.sel = self.u.select_atoms(self.sel_str)[:natoms]\n        except AttributeError:\n            self.sel = self.u.selectAtoms(self.sel_str)[:natoms]\n    \n        # do not include initialization of the\n        # InterRDF object in the benchmark itself\n    \n        self.rdf = InterRDF(g1=self.sel,\n                            g2=self.sel,\n                            nbins=nbins,\n                            range=range_val)",
        "name": "analysis.rdf.SimpleRdfBench.time_interrdf",
        "number": 0,
        "param_names": [
            "nbins",
            "range_val",
            "natoms"
        ],
        "params": [
            [
                "20",
                "75",
                "200"
            ],
            [
                "[0, 5]",
                "[0, 15]",
                "[0, 20]"
            ],
            [
                "1",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "9ebb9a21c33cde32547d998c7529ce6b477a31146f92a21cb7ddcd869f059292",
        "warmup_time": -1
    },
    "analysis.rms.RmsdTrajBench.time_RMSD": {
        "code": "class RmsdTrajBench:\n    def time_RMSD(self, select, weights):\n        \"\"\"Benchmark RMSD.run() method, which parses\n        over the entire trajectory.\n        \"\"\"\n        self.RMSD_inst.run()\n\n    def setup(self, select, weights):\n        self.u = MDAnalysis.Universe(PSF, DCD)\n        self.RMSD_inst = rms.RMSD(atomgroup=self.u,\n                                  reference=None,\n                                  select=select,\n                                  weights=weights)",
        "name": "analysis.rms.RmsdTrajBench.time_RMSD",
        "number": 0,
        "param_names": [
            "select",
            "weights"
        ],
        "params": [
            [
                "'all'",
                "'backbone'"
            ],
            [
                "None",
                "'mass'"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "64836ac01572a5047b1dd99fff0059e19db814e8d869fba0f667e8ce391dab94",
        "warmup_time": -1
    },
    "analysis.rms.RmsfTrajBench.time_RMSF": {
        "code": "class RmsfTrajBench:\n    def time_RMSF(self, n_atoms, step, weights):\n        \"\"\"Benchmark RMSF.run() method, which parses\n        over the entire trajectory.\n        \"\"\"\n        self.RMSF_inst.run()\n\n    def setup(self, n_atoms, step, weights):\n        self.u = MDAnalysis.Universe(PSF, DCD)\n        self.ag = self.u.atoms[:n_atoms]\n        self.RMSF_inst = rms.RMSF(atomgroup=self.ag,\n                                  start=None,\n                                  stop=None,\n                                  step=step,\n                                  weights=weights)",
        "name": "analysis.rms.RmsfTrajBench.time_RMSF",
        "number": 0,
        "param_names": [
            "n_atoms",
            "step",
            "weights"
        ],
        "params": [
            [
                "100",
                "500",
                "2000"
            ],
            [
                "None",
                "3"
            ],
            [
                "None",
                "'mass'"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "51fa8961bb7846d8b1a47b3169c16b28ce31a4a9888dcf935747cc9ae82eb9a4",
        "warmup_time": -1
    },
    "analysis.rms.SimpleRmsBench.time_rmsd": {
        "code": "class SimpleRmsBench:\n    def time_rmsd(self, num_atoms, weights, center, superposition):\n        \"\"\"Benchmark rmsd function using a setup similar to\n        its docstring example code along with several possible\n        permutations of parameters.\n        \"\"\"\n        rms.rmsd(a=self.A,\n                 b=self.B,\n                 weights=weights,\n                 center=center,\n                 superposition=superposition)\n\n    def setup(self, num_atoms, weights, center, superposition):\n        # mimic rmsd docstring example code\n        self.u = MDAnalysis.Universe(PSF, DCD)\n        # ag.positions is the new syntax\n        # but older commit hashes will need to use\n        # ag.coordinates()\n        try:\n            self.A = self.u.atoms.positions.copy()[:num_atoms]\n            self.u.trajectory[-1]\n            self.B = self.u.atoms.positions.copy()[:num_atoms]\n        except:\n            self.A = self.u.atoms.coordinates().copy()[:num_atoms]\n            self.u.trajectory[-1]\n            self.B = self.u.atoms.coordinates().copy()[:num_atoms]",
        "name": "analysis.rms.SimpleRmsBench.time_rmsd",
        "number": 0,
        "param_names": [
            "num_atoms",
            "weights",
            "center",
            "superposition"
        ],
        "params": [
            [
                "100",
                "500",
                "2000"
            ],
            [
                "None",
                "[1.0, 0.5]"
            ],
            [
                "False",
                "True"
            ],
            [
                "False",
                "True"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "3730cce32247fa610cb1fcb58e054dc42bd0d1dd6ee55a5d19e01cff3ade58d1",
        "warmup_time": -1
    },
    "import.ImportBench.time_import": {
        "code": "class ImportBench:\n    def time_import(self):\n        \"\"\"Benchmark time needed to import MDAnalysis\n        \"\"\"\n        import MDAnalysis as mda\n        pass",
        "name": "import.ImportBench.time_import",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "61f437034b6040b9faf8e324049e743318ff56255c98cd868a547bac5c256124",
        "warmup_time": -1
    },
    "selections.GeoSelectionBench.time_geometric_selections": {
        "code": "class GeoSelectionBench:\n    def time_geometric_selections(self,\n                                  selection_string,\n                                  dynamic_selection,\n                                  periodic_selection):\n    \n        # set core flags for PBC accounting\n        MDAnalysis.core.flags['use_periodic_selections'] = periodic_selection[0]\n        MDAnalysis.core.flags['use_KDTree_routines'] = periodic_selection[1]\n    \n        if hasattr(MDAnalysis.Universe, 'select_atoms'):\n            self.u.select_atoms(selection_string, updating=dynamic_selection)\n        else:\n            self.u.selectAtoms(selection_string, updating=dynamic_selection)\n\n    def setup(self,\n              selection_string,\n              dynamic_selection,\n              periodic_selection):\n        self.u = MDAnalysis.Universe(GRO)",
        "name": "selections.GeoSelectionBench.time_geometric_selections",
        "number": 0,
        "param_names": [
            "selection_string",
            "dynamic_selection",
            "periodic_selection"
        ],
        "params": [
            [
                "'around 5.0 resid 1'",
                "'sphlayer 2.4 6.0 (protein)'",
                "'sphzone 6.0 (protein)'",
                "'cylayer 5 10 10 -8 protein'",
                "'cyzone 15 4 -8 protein'",
                "'point 5.0 5.0 5.0 3.5'",
                "'prop z >= 5.0'",
                "'prop abs z <= 5.0'"
            ],
            [
                "True",
                "False"
            ],
            [
                "[False, True]",
                "[True, False]"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "b1d29e5a574daee7de2e1c37536258165a3371b550cd29fc2f41c55e796001e1",
        "warmup_time": -1
    },
    "selections.SimpleSelectionBench.time_simple_selections": {
        "code": "class SimpleSelectionBench:\n    def time_simple_selections(self, selection_string):\n        \"\"\"Benchmark simple selections on the protein-based\n        standard test GRO file.\n        \"\"\"\n        if hasattr(MDAnalysis.Universe, 'select_atoms'):\n            self.u.select_atoms(selection_string)\n        else:\n            self.u.selectAtoms(selection_string)\n\n    def setup(self, selection_string):\n        self.u = MDAnalysis.Universe(GRO)",
        "name": "selections.SimpleSelectionBench.time_simple_selections",
        "number": 0,
        "param_names": [
            "selection_string"
        ],
        "params": [
            [
                "'protein'",
                "'backbone'",
                "'nucleic'",
                "'nucleicbackbone'",
                "'resid 1:10'",
                "'resnum 1:10'",
                "'resname LYS'",
                "'name CA'",
                "'bynum 0:10'"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "3d7336e8388a8daf7d76bc3faec4ee662f2ddce17529d2b322ec539be91758c3",
        "warmup_time": -1
    },
    "topology.TopologyGuessBench.time_guessbonds": {
        "code": "class TopologyGuessBench:\n    def time_guessbonds(self, num_atoms):\n        \"\"\"Benchmark for guessing bonds\"\"\"\n        guessers.guess_bonds(self.ag, self.ag.positions,\n                             box=self.ag.dimensions,\n                             vdwradii=self.vdwradii)\n\n    def setup(self, num_atoms):\n        self.u = MDAnalysis.Universe(GRO)\n        self.ag = self.u.atoms[:num_atoms]\n        self.vdwradii = {'H':1.0,\n                         'C':1.0,\n                         'N':1.0,\n                         'O':1.0,\n                         'DUMMY':1.0}",
        "name": "topology.TopologyGuessBench.time_guessbonds",
        "number": 0,
        "param_names": [
            "num_atoms"
        ],
        "params": [
            [
                "10",
                "100",
                "1000",
                "10000"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "c8b85b9228a93b83692b65e61c7a9fdd017ca22d7702f18034d1a5f2c068bcb7",
        "warmup_time": -1
    },
    "traj_reader.TrajReaderCreation.time_reads": {
        "code": "class TrajReaderCreation:\n    def time_reads(self, traj_format):\n        \"\"\"Simple benchmark for reading traj file formats\n        from our standard test files.\n        \"\"\"\n        self.traj_reader(self.traj_file)\n\n    def setup(self, traj_format):\n        self.traj_dict = traj_dict\n        self.traj_file, self.traj_reader = self.traj_dict[traj_format]",
        "name": "traj_reader.TrajReaderCreation.time_reads",
        "number": 0,
        "param_names": [
            "traj_format"
        ],
        "params": [
            [
                "'XTC'",
                "'TRR'",
                "'DCD'",
                "'NCDF'"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "4b030c7c2af116b5eaaec4c77913ed39dda95d0f355f11be9ee99403dfa71f93",
        "warmup_time": -1
    },
    "traj_reader.TrajReaderIteration.time_strides": {
        "code": "class TrajReaderIteration:\n    def time_strides(self, traj_format):\n        \"\"\"Benchmark striding over full trajectory\n        test files for each format.\n        \"\"\"\n        for ts in self.reader_object:\n            pass\n\n    def setup(self, traj_format):\n        self.traj_dict = traj_dict\n        self.traj_file, self.traj_reader = self.traj_dict[traj_format]\n        self.reader_object = self.traj_reader(self.traj_file)",
        "name": "traj_reader.TrajReaderIteration.time_strides",
        "number": 0,
        "param_names": [
            "traj_format"
        ],
        "params": [
            [
                "'XTC'",
                "'TRR'",
                "'DCD'",
                "'NCDF'"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "d2890f87c636b5336c33c4ede5c97f90f26b52ea890f4514459dee27de3b92fc",
        "warmup_time": -1
    },
    "version": 1
}